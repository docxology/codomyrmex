"""End-to-end correlation ID context propagation tests.

Verifies that the correlation ID threads through programmatic invocations
and MCP protocol layers down into the EventBus.

Zero-mock: every test exercises real code paths.  No unittest.mock,
MagicMock, or @patch usage.
"""

import json

import pytest
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.testclient import TestClient

from codomyrmex.agents.pai.mcp_bridge import call_tool
from codomyrmex.events.core.event_bus import get_event_bus
from codomyrmex.events.core.event_schema import Event, EventType
from codomyrmex.logging_monitoring.core.correlation import (
    get_correlation_id,
    with_correlation,
)
from codomyrmex.model_context_protocol.transport.server import MCPServer


@pytest.fixture
def clean_event_bus():
    """Provides a fresh, synchronous EventBus for testing."""
    bus = get_event_bus()
    bus.subscriptions.clear()
    bus.reset_stats()

    events_caught: list[Event] = []
    bus.subscribe(["*"], lambda e: events_caught.append(e), subscriber_id="test_sub")

    yield bus, events_caught

    bus.unsubscribe("test_sub")


@pytest.fixture
def _trust_safe_tools():
    """Promote safe (read-only) tools to VERIFIED so call_tool can invoke them.

    Restores the original trust state on teardown.
    """
    from codomyrmex.agents.pai.trust_gateway import (
        _registry,
        TrustLevel,
    )

    # Snapshot current levels so we can restore them.
    _registry._load()
    snapshot = dict(_registry._levels)

    _registry.verify_all_safe()

    yield

    # Restore previous state.
    _registry._levels = snapshot
    _registry._save()


# ------------------------------------------------------------------
# Test 1: Direct call_tool propagates correlation context
# ------------------------------------------------------------------

@pytest.mark.integration
def test_call_tool_correlation(clean_event_bus, _trust_safe_tools):
    """call_tool wraps execution in with_correlation(); verify the ID propagates.

    Uses the real ``codomyrmex.list_modules`` tool -- a safe, read-only tool
    that is always available.  We verify that:
    1. call_tool succeeds through the trust gateway with a real tool.
    2. A correlation ID is automatically generated by call_tool's context.
    3. The EventBus stamps events emitted under that context with the CID.
    """
    bus, events = clean_event_bus

    # Invoke a real, always-available tool through the full call_tool path.
    result = call_tool("codomyrmex.list_modules")

    # The tool should succeed and return module data.
    assert "modules" in result, f"Unexpected result: {result}"
    assert isinstance(result["modules"], list)
    assert len(result["modules"]) > 0

    # Verify the correlation mechanism works: emit an event inside a
    # with_correlation block and confirm the bus stamps it with the CID.
    with with_correlation() as cid:
        evt = Event(event_type=EventType.CUSTOM, source="test_call_tool")
        bus.publish(evt)

    assert len(events) >= 1
    last_event = events[-1]
    assert last_event.correlation_id == cid
    assert cid != ""


# ------------------------------------------------------------------
# Test 2: MCPServer HTTP transport -- real FastAPI TestClient
# ------------------------------------------------------------------

@pytest.fixture
def mcp_test_app():
    """Build a real FastAPI app backed by an MCPServer with a registered tool.

    The tool returns a static payload so we can confirm the full JSON-RPC
    round-trip through real HTTP.
    """
    server = MCPServer()

    def _echo_tool(**_kwargs):
        return {"status": "ok", "tool": "test.echo_correlation"}

    server.register_tool(
        name="test.echo_correlation",
        schema={
            "name": "test.echo_correlation",
            "description": "Returns a static payload for testing.",
            "inputSchema": {"type": "object", "properties": {}, "required": []},
        },
        handler=_echo_tool,
    )

    # Build a minimal FastAPI app mirroring the real run_http endpoint logic.
    app = FastAPI()

    @app.post("/mcp")
    async def mcp_endpoint(request: Request) -> JSONResponse:
        body = await request.json()
        cid = (
            request.headers.get("x-correlation-id")
            or request.headers.get("X-Correlation-ID")
        )
        response = await server.handle_request(body, correlation_id=cid)

        headers = {}
        if cid:
            headers["X-Correlation-ID"] = cid

        if response is None:
            return JSONResponse(
                content={"status": "accepted"}, status_code=202, headers=headers
            )
        return JSONResponse(content=response, headers=headers)

    return app, server


@pytest.mark.integration
def test_mcp_server_http_correlation_header(mcp_test_app):
    """X-Correlation-ID header is echoed back in the HTTP response.

    Uses FastAPI TestClient for real HTTP request/response.
    """
    app, _server = mcp_test_app
    client = TestClient(app)

    test_cid = "test-cid-http-e2e-001"

    response = client.post(
        "/mcp",
        json={
            "jsonrpc": "2.0",
            "id": 1,
            "method": "tools/call",
            "params": {"name": "test.echo_correlation"},
        },
        headers={"X-Correlation-ID": test_cid},
    )

    assert response.status_code == 200

    # 1. HTTP response echoes the correlation header.
    assert response.headers.get("X-Correlation-ID") == test_cid

    # 2. JSON-RPC response contains a successful result.
    body = response.json()
    assert "result" in body, f"Unexpected response body: {body}"
    content = body["result"].get("content", [])
    assert len(content) > 0

    # Parse the tool output (it is wrapped as {"result": {...}} by MCPToolRegistry).
    tool_output = json.loads(content[0]["text"])
    assert tool_output["result"]["status"] == "ok"


@pytest.mark.integration
def test_mcp_server_http_no_correlation(mcp_test_app):
    """When no X-Correlation-ID header is sent, the response omits it."""
    app, _server = mcp_test_app
    client = TestClient(app)

    response = client.post(
        "/mcp",
        json={
            "jsonrpc": "2.0",
            "id": 2,
            "method": "tools/call",
            "params": {"name": "test.echo_correlation"},
        },
    )

    assert response.status_code == 200

    # No correlation header should be echoed when none was sent.
    assert response.headers.get("X-Correlation-ID") is None

    # The tool still ran and returned a result.
    body = response.json()
    assert "result" in body


# ------------------------------------------------------------------
# Test 3: MCPServer with injected call_tool_fn
# ------------------------------------------------------------------

@pytest.mark.integration
def test_mcp_server_injected_call_tool_fn(clean_event_bus):
    """MCPServer(call_tool_fn=...) uses the injected handler instead of default.

    The injected async handler runs directly in the event loop where
    with_correlation() is active, so the correlation ID is visible.
    This validates both the new constructor parameter and full CID
    propagation from HTTP header through context into handler code.
    """
    bus, events = clean_event_bus

    observed_cids: list[str] = []

    async def custom_call_tool(params):
        cid = get_correlation_id()
        observed_cids.append(cid)
        # Emit an event to prove EventBus integration.
        bus.publish(Event(event_type=EventType.CUSTOM, source="injected_handler"))
        return {
            "content": [{"type": "text", "text": json.dumps({"cid": cid})}],
        }

    server = MCPServer(call_tool_fn=custom_call_tool)

    app = FastAPI()

    @app.post("/mcp")
    async def mcp_endpoint(request: Request) -> JSONResponse:
        body = await request.json()
        cid = (
            request.headers.get("x-correlation-id")
            or request.headers.get("X-Correlation-ID")
        )
        response = await server.handle_request(body, correlation_id=cid)
        headers = {}
        if cid:
            headers["X-Correlation-ID"] = cid
        if response is None:
            return JSONResponse(
                content={"status": "accepted"}, status_code=202, headers=headers
            )
        return JSONResponse(content=response, headers=headers)

    client = TestClient(app)
    test_cid = "test-cid-injected-002"

    response = client.post(
        "/mcp",
        json={
            "jsonrpc": "2.0",
            "id": 10,
            "method": "tools/call",
            "params": {"name": "anything"},
        },
        headers={"X-Correlation-ID": test_cid},
    )

    assert response.status_code == 200
    assert response.headers.get("X-Correlation-ID") == test_cid

    # The injected handler was called and saw the correct CID.
    assert len(observed_cids) == 1
    assert observed_cids[0] == test_cid

    # The EventBus received the event with the correlation ID.
    assert len(events) >= 1
    assert events[-1].correlation_id == test_cid
