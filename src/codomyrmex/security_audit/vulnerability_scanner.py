"""
Vulnerability Scanner for Codomyrmex Security Audit Module.

Provides comprehensive vulnerability scanning capabilities including:
- Dependency vulnerability scanning
- Code security analysis
- Compliance checking
- Risk assessment and reporting
"""

import os
import sys
import json
import subprocess
import hashlib
import re
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
import tempfile

# Add project root to Python path
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, "..", ".."))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

try:
    from logging_monitoring.logger_config import get_logger

    logger = get_logger(__name__)
except ImportError:
    import logging

    logger = logging.getLogger(__name__)

try:
    from performance import monitor_performance, performance_context

    PERFORMANCE_MONITORING_AVAILABLE = True
except ImportError:
    PERFORMANCE_MONITORING_AVAILABLE = False


class SeverityLevel(Enum):
    """Security severity levels."""

    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


class ComplianceStandard(Enum):
    """Supported compliance standards."""

    OWASP_TOP_10 = "OWASP_TOP_10"
    NIST_800_53 = "NIST_800_53"
    ISO_27001 = "ISO_27001"
    PCI_DSS = "PCI_DSS"
    GDPR = "GDPR"
    HIPAA = "HIPAA"


@dataclass
class VulnerabilityReport:
    """Comprehensive vulnerability assessment report."""

    scan_id: str
    timestamp: datetime
    target_path: str
    vulnerabilities: List[Dict[str, Any]] = field(default_factory=list)
    compliance_checks: List[Dict[str, Any]] = field(default_factory=list)
    risk_score: float = 0.0
    recommendations: List[str] = field(default_factory=list)
    scan_duration: float = 0.0
    scan_status: str = "pending"

    def to_dict(self) -> Dict[str, Any]:
        """Convert report to dictionary format."""
        return {
            "scan_id": self.scan_id,
            "timestamp": self.timestamp.isoformat(),
            "target_path": self.target_path,
            "vulnerabilities": self.vulnerabilities,
            "compliance_checks": self.compliance_checks,
            "risk_score": self.risk_score,
            "recommendations": self.recommendations,
            "scan_duration": self.scan_duration,
            "scan_status": self.scan_status,
        }


@dataclass
class SecurityScanResult:
    """Results from a security scan operation."""

    component: str
    scan_type: str
    findings: List[Dict[str, Any]]
    passed: bool
    timestamp: datetime
    details: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ComplianceCheck:
    """Compliance verification result."""

    standard: str
    requirement: str
    status: str  # "compliant", "non_compliant", "not_applicable"
    evidence: str
    remediation: Optional[str] = None
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner for code and dependencies.

    Supports multiple scanning methods:
    - Dependency vulnerability scanning (pip-audit, safety)
    - Code security analysis (bandit, semgrep)
    - Compliance checking
    - Risk assessment
    """

    def __init__(self, config_path: Optional[str] = None):
        """
        Initialize the vulnerability scanner.

        Args:
            config_path: Path to scanner configuration file
        """
        self.config_path = config_path or os.path.join(
            os.getcwd(), "security_config.json"
        )
        self.config = self._load_config()
        self.scan_results: List[VulnerabilityReport] = []

    def _load_config(self) -> Dict[str, Any]:
        """Load scanner configuration."""
        default_config = {
            "scan_types": ["dependencies", "code", "compliance"],
            "severity_threshold": "MEDIUM",
            "compliance_standards": ["OWASP_TOP_10"],
            "exclude_patterns": ["*.pyc", "__pycache__/*", ".git/*"],
            "max_scan_time": 300,  # 5 minutes
            "parallel_scans": True,
            "cache_results": True,
            "cache_ttl": 3600,  # 1 hour
        }

        if os.path.exists(self.config_path):
            try:
                with open(self.config_path, "r") as f:
                    user_config = json.load(f)
                default_config.update(user_config)
            except Exception as e:
                logger.warning(f"Failed to load config: {e}")

        return default_config

    def scan_vulnerabilities(
        self, target_path: str, scan_types: Optional[List[str]] = None
    ) -> VulnerabilityReport:
        """
        Perform comprehensive vulnerability scan.

        Args:
            target_path: Path to scan (file or directory)
            scan_types: Types of scans to perform

        Returns:
            VulnerabilityReport: Comprehensive scan results
        """
        scan_id = self._generate_scan_id(target_path)
        start_time = datetime.now(timezone.utc)

        logger.info(f"Starting vulnerability scan {scan_id} for {target_path}")

        if scan_types is None:
            scan_types = self.config.get("scan_types", ["dependencies", "code"])

        report = VulnerabilityReport(
            scan_id=scan_id,
            timestamp=start_time,
            target_path=target_path,
            scan_status="running",
        )

        try:
            # Perform requested scan types
            if "dependencies" in scan_types:
                dep_vulns = self._scan_dependencies(target_path)
                report.vulnerabilities.extend(dep_vulns)

            if "code" in scan_types:
                code_vulns = self._scan_code_security(target_path)
                report.vulnerabilities.extend(code_vulns)

            if "compliance" in scan_types:
                compliance_results = self._check_compliance(target_path)
                report.compliance_checks.extend(compliance_results)

            # Calculate risk score and generate recommendations
            report.risk_score = self._calculate_risk_score(report.vulnerabilities)
            report.recommendations = self._generate_recommendations(
                report.vulnerabilities
            )

            # Update scan duration and status
            end_time = datetime.now(timezone.utc)
            report.scan_duration = (end_time - start_time).total_seconds()
            report.scan_status = "completed"

            self.scan_results.append(report)

            logger.info(
                f"Vulnerability scan {scan_id} completed in {report.scan_duration:.2f}s"
            )

        except Exception as e:
            logger.error(f"Vulnerability scan {scan_id} failed: {e}")
            report.scan_status = "failed"
            report.recommendations.append(f"Scan failed: {str(e)}")

        return report

    def _scan_dependencies(self, target_path: str) -> List[Dict[str, Any]]:
        """Scan dependencies for vulnerabilities."""
        vulnerabilities = []

        # Check for Python dependencies
        if self._is_python_project(target_path):
            vulnerabilities.extend(self._scan_python_dependencies(target_path))

        # Check for Node.js dependencies
        if self._is_nodejs_project(target_path):
            vulnerabilities.extend(self._scan_nodejs_dependencies(target_path))

        return vulnerabilities

    def _scan_python_dependencies(self, target_path: str) -> List[Dict[str, Any]]:
        """Scan Python dependencies for vulnerabilities."""
        vulnerabilities = []

        # Check for requirements.txt
        req_file = os.path.join(target_path, "requirements.txt")
        if os.path.exists(req_file):
            try:
                # Use pip-audit if available
                result = subprocess.run(
                    [
                        sys.executable,
                        "-m",
                        "pip_audit",
                        "--format",
                        "json",
                        "-r",
                        req_file,
                    ],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )

                if result.returncode == 0 and result.stdout:
                    audit_results = json.loads(result.stdout)
                    for vuln in audit_results:
                        vulnerabilities.append(
                            {
                                "type": "dependency",
                                "severity": vuln.get("severity", "UNKNOWN"),
                                "package": vuln.get("name", ""),
                                "version": vuln.get("version", ""),
                                "description": vuln.get("description", ""),
                                "cve_id": vuln.get("cve_id", ""),
                                "fix_available": vuln.get("fix_available", False),
                            }
                        )

            except (
                subprocess.TimeoutExpired,
                FileNotFoundError,
                json.JSONDecodeError,
            ) as e:
                logger.warning(f"Python dependency scan failed: {e}")

        return vulnerabilities

    def _scan_nodejs_dependencies(self, target_path: str) -> List[Dict[str, Any]]:
        """Scan Node.js dependencies for vulnerabilities."""
        vulnerabilities = []

        # Check for package.json
        pkg_file = os.path.join(target_path, "package.json")
        if os.path.exists(pkg_file):
            try:
                # Use npm audit if available
                result = subprocess.run(
                    ["npm", "audit", "--audit-level", "moderate", "--json"],
                    cwd=target_path,
                    capture_output=True,
                    text=True,
                    timeout=60,
                )

                if result.returncode == 0 and result.stdout:
                    audit_results = json.loads(result.stdout)
                    if "vulnerabilities" in audit_results:
                        for vuln_name, vuln_data in audit_results[
                            "vulnerabilities"
                        ].items():
                            vulnerabilities.append(
                                {
                                    "type": "dependency",
                                    "severity": vuln_data.get("severity", "UNKNOWN"),
                                    "package": vuln_name,
                                    "version": vuln_data.get("version", ""),
                                    "description": vuln_data.get("title", ""),
                                    "fix_available": vuln_data.get(
                                        "fixAvailable", False
                                    ),
                                }
                            )

            except (
                subprocess.TimeoutExpired,
                FileNotFoundError,
                json.JSONDecodeError,
            ) as e:
                logger.warning(f"Node.js dependency scan failed: {e}")

        return vulnerabilities

    def _scan_code_security(self, target_path: str) -> List[Dict[str, Any]]:
        """Scan code for security vulnerabilities."""
        vulnerabilities = []

        # Use bandit for Python security scanning
        if self._is_python_project(target_path):
            try:
                result = subprocess.run(
                    [sys.executable, "-m", "bandit", "-f", "json", "-r", target_path],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )

                if result.returncode == 0 and result.stdout:
                    bandit_results = json.loads(result.stdout)
                    for result_item in bandit_results.get("results", []):
                        for issue in result_item.get("issues", []):
                            vulnerabilities.append(
                                {
                                    "type": "code",
                                    "severity": issue.get("severity", "UNKNOWN"),
                                    "file": result_item.get("filename", ""),
                                    "line": issue.get("line_number", 0),
                                    "description": issue.get("text", ""),
                                    "cwe_id": issue.get("cwe", {}).get("id", ""),
                                    "confidence": issue.get("confidence", "UNKNOWN"),
                                }
                            )

            except (
                subprocess.TimeoutExpired,
                FileNotFoundError,
                json.JSONDecodeError,
            ) as e:
                logger.warning(f"Code security scan failed: {e}")

        return vulnerabilities

    def _check_compliance(self, target_path: str) -> List[Dict[str, Any]]:
        """Check compliance with security standards."""
        compliance_results = []

        standards = self.config.get("compliance_standards", ["OWASP_TOP_10"])

        for standard in standards:
            if standard == "OWASP_TOP_10":
                compliance_results.extend(self._check_owasp_compliance(target_path))

        return compliance_results

    def _check_owasp_compliance(self, target_path: str) -> List[Dict[str, Any]]:
        """Check OWASP Top 10 compliance."""
        compliance_checks = []

        # OWASP A01:2021 - Broken Access Control
        compliance_checks.append(
            {
                "standard": "OWASP_TOP_10",
                "requirement": "A01:2021 - Broken Access Control",
                "status": "not_checked",
                "evidence": "Manual review required",
                "remediation": "Implement proper access control mechanisms",
            }
        )

        # OWASP A02:2021 - Cryptographic Failures
        compliance_checks.append(
            {
                "standard": "OWASP_TOP_10",
                "requirement": "A02:2021 - Cryptographic Failures",
                "status": "not_checked",
                "evidence": "Check for proper encryption usage",
                "remediation": "Use strong encryption algorithms and proper key management",
            }
        )

        # Add more OWASP checks as needed...

        return compliance_checks

    def _calculate_risk_score(self, vulnerabilities: List[Dict[str, Any]]) -> float:
        """Calculate overall risk score from vulnerabilities."""
        if not vulnerabilities:
            return 0.0

        severity_weights = {
            "CRITICAL": 1.0,
            "HIGH": 0.8,
            "MEDIUM": 0.6,
            "LOW": 0.3,
            "INFO": 0.1,
        }

        total_score = 0.0
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "UNKNOWN")
            weight = severity_weights.get(severity.upper(), 0.5)
            total_score += weight

        # Normalize to 0-100 scale
        return min(100.0, total_score * 10)

    def _generate_recommendations(
        self, vulnerabilities: List[Dict[str, Any]]
    ) -> List[str]:
        """Generate security recommendations based on findings."""
        recommendations = []

        if not vulnerabilities:
            recommendations.append(
                "✅ No security vulnerabilities found - continue monitoring"
            )
            return recommendations

        # Group vulnerabilities by type
        dep_vulns = [v for v in vulnerabilities if v.get("type") == "dependency"]
        code_vulns = [v for v in vulnerabilities if v.get("type") == "code"]

        if dep_vulns:
            recommendations.append(
                f"⚠️ Found {len(dep_vulns)} dependency vulnerabilities - update packages"
            )
            recommendations.append(
                "Run: pip-audit or safety check for detailed dependency analysis"
            )

        if code_vulns:
            recommendations.append(
                f"⚠️ Found {len(code_vulns)} code security issues - review and fix"
            )
            recommendations.append(
                "Use bandit or similar tools for automated code security scanning"
            )

        # Severity-based recommendations
        critical_vulns = [v for v in vulnerabilities if v.get("severity") == "CRITICAL"]
        if critical_vulns:
            recommendations.append(
                "🚨 CRITICAL vulnerabilities found - immediate attention required!"
            )

        return recommendations

    def _generate_scan_id(self, target_path: str) -> str:
        """Generate unique scan ID."""
        timestamp = datetime.now(timezone.utc).isoformat()
        path_hash = hashlib.md5(target_path.encode()).hexdigest()[:8]
        return f"scan_{path_hash}_{timestamp}"

    def _is_python_project(self, target_path: str) -> bool:
        """Check if target is a Python project."""
        python_indicators = [
            "requirements.txt",
            "setup.py",
            "pyproject.toml",
            "Pipfile",
        ]
        return any(
            os.path.exists(os.path.join(target_path, indicator))
            for indicator in python_indicators
        )

    def _is_nodejs_project(self, target_path: str) -> bool:
        """Check if target is a Node.js project."""
        nodejs_indicators = ["package.json", "package-lock.json", "yarn.lock"]
        return any(
            os.path.exists(os.path.join(target_path, indicator))
            for indicator in nodejs_indicators
        )


# Convenience functions
def scan_vulnerabilities(
    target_path: str, scan_types: Optional[List[str]] = None
) -> VulnerabilityReport:
    """
    Convenience function to scan vulnerabilities.

    Args:
        target_path: Path to scan
        scan_types: Types of scans to perform

    Returns:
        VulnerabilityReport: Scan results
    """
    scanner = VulnerabilityScanner()
    return scanner.scan_vulnerabilities(target_path, scan_types)


def audit_code_security(target_path: str) -> List[Dict[str, Any]]:
    """
    Convenience function for code security auditing.

    Args:
        target_path: Path to audit

    Returns:
        List of security findings
    """
    scanner = VulnerabilityScanner()
    report = scanner.scan_vulnerabilities(target_path, ["code"])
    return report.vulnerabilities


def check_compliance(
    target_path: str, standards: Optional[List[str]] = None
) -> List[Dict[str, Any]]:
    """
    Convenience function for compliance checking.

    Args:
        target_path: Path to check
        standards: Compliance standards to check

    Returns:
        List of compliance check results
    """
    scanner = VulnerabilityScanner()
    if standards:
        scanner.config["compliance_standards"] = standards

    report = scanner.scan_vulnerabilities(target_path, ["compliance"])
    return report.compliance_checks
