from dataclasses import dataclass
from datetime import datetime, timedelta

from codomyrmex.logging_monitoring.core.logger_config import get_logger
from codomyrmex.security.physical.access_control import AccessControlSystem
from codomyrmex.security.physical.asset_inventory import AssetInventory
from codomyrmex.security.physical.perimeter_management import PerimeterManager
from codomyrmex.security.physical.surveillance import SurveillanceMonitor

"""Physical vulnerability assessment."""

logger = get_logger(__name__)


@dataclass
class PhysicalVulnerability:
    """Represents a physical security vulnerability."""

    vulnerability_id: str
    location: str
    vulnerability_type: str
    severity: str  # low, medium, high, critical
    description: str
    recommendation: str


class PhysicalVulnerabilityScanner:
    """Scans for physical security vulnerabilities."""

    def __init__(
        self,
        access_control: AccessControlSystem | None = None,
        perimeter: PerimeterManager | None = None,
        surveillance: SurveillanceMonitor | None = None,
        inventory: AssetInventory | None = None,
    ):
        """Execute   Init   operations natively."""
        self.access_control: AccessControlSystem | None = access_control
        self.perimeter: PerimeterManager | None = perimeter
        self.surveillance: SurveillanceMonitor | None = surveillance
        self.inventory: AssetInventory | None = inventory
        logger.info("PhysicalVulnerabilityScanner initialized")

    def scan_vulnerabilities(self, location: str) -> list[PhysicalVulnerability]:
        """Scan for physical vulnerabilities at a location."""
        vulnerabilities = []
        vuln_counter = 1
        now = datetime.now()

        # Check access control for expired permissions
        if self.access_control is not None:
            for user_id, perms in self.access_control.permissions.items():
                for perm in perms:
                    if perm.expires_at is not None and perm.expires_at < now:
                        vulnerabilities.append(PhysicalVulnerability(
                            vulnerability_id=f"PV-{vuln_counter:03d}",
                            location=location,
                            vulnerability_type="expired_permission",
                            severity="medium",
                            description=f"Expired access permission for user '{user_id}' on resource '{perm.resource}' (expired {perm.expires_at.isoformat()})",
                            recommendation="Revoke expired permissions and implement automated permission expiry cleanup",
                        ))
                        vuln_counter += 1

        # Check perimeter for low-security access points
        if self.perimeter is not None:
            for point in self.perimeter.access_points.values():
                if point.security_level == "low":
                    vulnerabilities.append(PhysicalVulnerability(
                        vulnerability_id=f"PV-{vuln_counter:03d}",
                        location=point.location,
                        vulnerability_type="low_security_access_point",
                        severity="high",
                        description=f"Access point '{point.point_id}' at '{point.location}' has low security level (type: {point.access_type})",
                        recommendation="Upgrade access point security with better locks, access cards, or surveillance",
                    ))
                    vuln_counter += 1
                if point.status != "active":
                    vulnerabilities.append(PhysicalVulnerability(
                        vulnerability_id=f"PV-{vuln_counter:03d}",
                        location=point.location,
                        vulnerability_type="inactive_access_point",
                        severity="medium",
                        description=f"Access point '{point.point_id}' at '{point.location}' is not active (status: {point.status})",
                        recommendation="Restore access point to active status or ensure it is physically secured",
                    ))
                    vuln_counter += 1

        # Check surveillance for gaps (few events logged)
        if self.surveillance is not None:
            if len(self.surveillance.events) < 5:
                vulnerabilities.append(PhysicalVulnerability(
                    vulnerability_id=f"PV-{vuln_counter:03d}",
                    location=location,
                    vulnerability_type="surveillance_gap",
                    severity="high",
                    description=f"Insufficient surveillance coverage: only {len(self.surveillance.events)} events logged (minimum recommended: 5)",
                    recommendation="Increase surveillance monitoring, add cameras or sensors, and verify logging systems are operational",
                ))
                vuln_counter += 1

        # Check inventory for stale assets
        if self.inventory is not None:
            stale_threshold = now - timedelta(days=90)
            for asset in self.inventory.assets.values():
                if asset.last_checked is None or asset.last_checked < stale_threshold:
                    last_info = "never checked" if asset.last_checked is None else f"last checked {asset.last_checked.isoformat()}"
                    vulnerabilities.append(PhysicalVulnerability(
                        vulnerability_id=f"PV-{vuln_counter:03d}",
                        location=asset.location,
                        vulnerability_type="stale_asset",
                        severity="medium",
                        description=f"Asset '{asset.asset_id}' ({asset.name}) has not been recently verified ({last_info})",
                        recommendation="Conduct physical asset audit and update inventory tracking records",
                    ))
                    vuln_counter += 1

        logger.info(f"Scanned {location} for physical vulnerabilities")
        return vulnerabilities

    def assess_physical_security(self, location: str) -> dict:
        """Assess overall physical security at a location."""
        vulnerabilities = self.scan_vulnerabilities(location)

        assessment = {
            "location": location,
            "total_vulnerabilities": len(vulnerabilities),
            "critical_count": sum(1 for v in vulnerabilities if v.severity == "critical"),
            "high_count": sum(1 for v in vulnerabilities if v.severity == "high"),
            "vulnerabilities": vulnerabilities,
        }

        logger.info(f"Assessed physical security for {location}")
        return assessment


def scan_physical_vulnerabilities(
    location: str,
    scanner: PhysicalVulnerabilityScanner | None = None,
) -> list[PhysicalVulnerability]:
    """Scan for physical vulnerabilities."""
    if scanner is None:
        scanner = PhysicalVulnerabilityScanner()
    return scanner.scan_vulnerabilities(location)


def assess_physical_security(
    location: str,
    scanner: PhysicalVulnerabilityScanner | None = None,
) -> dict:
    """Assess physical security."""
    if scanner is None:
        scanner = PhysicalVulnerabilityScanner()
    return scanner.assess_physical_security(location)


