"""Automated CVE scanning against dependencies.

Scans installed packages for known vulnerabilities using
pip-audit and the OSV database.
"""

from __future__ import annotations

import json
import logging
import subprocess
from dataclasses import dataclass, field
from typing import Any

logger = logging.getLogger(__name__)


@dataclass
class Vulnerability:
    """A detected vulnerability."""
    package: str
    installed_version: str
    vulnerability_id: str
    description: str
    fix_versions: list[str] = field(default_factory=list)
    severity: str = "unknown"
    url: str = ""

    def to_dict(self) -> dict[str, Any]:
        """Return a dictionary representation of this object."""
        return {
            "package": self.package,
            "installed_version": self.installed_version,
            "vulnerability_id": self.vulnerability_id,
            "description": self.description,
            "fix_versions": self.fix_versions,
            "severity": self.severity,
            "url": self.url,
        }


@dataclass
class ScanReport:
    """Result of a vulnerability scan."""
    vulnerabilities: list[Vulnerability] = field(default_factory=list)
    packages_scanned: int = 0
    scan_tool: str = ""
    success: bool = True
    error: str | None = None

    @property
    def critical_count(self) -> int:
        """critical Count ."""
        return sum(1 for v in self.vulnerabilities if v.severity == "critical")

    @property
    def high_count(self) -> int:
        """high Count ."""
        return sum(1 for v in self.vulnerabilities if v.severity == "high")


class VulnerabilityScanner:
    """Scan Python dependencies for known vulnerabilities.

    Uses pip-audit (if available) or falls back to manual
    OSV API queries.
    """

    def __init__(self, python_path: str = "python") -> None:
        """Initialize this instance."""
        self._python = python_path

    def scan_pip_audit(self) -> ScanReport:
        """Scan using pip-audit (must be installed)."""
        try:
            result = subprocess.run(
                [self._python, "-m", "pip_audit", "--format=json", "--progress-spinner=off"],
                capture_output=True, text=True, timeout=120,
            )
            if result.returncode == 0 and not result.stdout.strip():
                return ScanReport(scan_tool="pip-audit", packages_scanned=0)

            data = json.loads(result.stdout) if result.stdout.strip() else {}
            vulns = []
            dependencies = data.get("dependencies", [])
            for dep in dependencies:
                for vuln in dep.get("vulns", []):
                    vulns.append(Vulnerability(
                        package=dep.get("name", ""),
                        installed_version=dep.get("version", ""),
                        vulnerability_id=vuln.get("id", ""),
                        description=vuln.get("description", ""),
                        fix_versions=vuln.get("fix_versions", []),
                        severity=vuln.get("aliases", ["unknown"])[0] if vuln.get("aliases") else "unknown",
                    ))
            return ScanReport(
                vulnerabilities=vulns,
                packages_scanned=len(dependencies),
                scan_tool="pip-audit",
            )
        except FileNotFoundError:
            return ScanReport(
                success=False,
                error="pip-audit not installed. Install with: pip install pip-audit",
                scan_tool="pip-audit",
            )
        except Exception as e:
            return ScanReport(success=False, error=str(e), scan_tool="pip-audit")

    def scan_safety(self) -> ScanReport:
        """Scan using safety (must be installed)."""
        try:
            result = subprocess.run(
                [self._python, "-m", "safety", "check", "--json"],
                capture_output=True, text=True, timeout=120,
            )
            data = json.loads(result.stdout) if result.stdout.strip() else []
            vulns = []
            for entry in data:
                if isinstance(entry, list) and len(entry) >= 5:
                    vulns.append(Vulnerability(
                        package=entry[0],
                        installed_version=entry[2],
                        vulnerability_id=entry[4] if len(entry) > 4 else "",
                        description=entry[3] if len(entry) > 3 else "",
                        severity="unknown",
                    ))
            return ScanReport(
                vulnerabilities=vulns,
                scan_tool="safety",
            )
        except Exception as e:
            return ScanReport(success=False, error=str(e), scan_tool="safety")

    def scan(self) -> ScanReport:
        """Run best available scanner."""
        report = self.scan_pip_audit()
        if report.success:
            return report
        return self.scan_safety()

    def generate_fix_commands(self, report: ScanReport) -> list[str]:
        """Generate pip install commands to fix vulnerabilities."""
        commands = []
        for vuln in report.vulnerabilities:
            if vuln.fix_versions:
                commands.append(
                    f"pip install '{vuln.package}>={vuln.fix_versions[-1]}'"
                )
        return list(set(commands))
