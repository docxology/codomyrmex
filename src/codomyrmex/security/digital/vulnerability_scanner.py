"""Vulnerability Scanner for Codomyrmex Security Audit Module.

Provides comprehensive vulnerability scanning capabilities including:
- Dependency vulnerability scanning
- Code security analysis
- Compliance checking
- Risk assessment and reporting
"""

import hashlib
import json
import os
from dataclasses import dataclass, field
from datetime import datetime, timezone, UTC
from enum import Enum
from typing import Any

from codomyrmex.logging_monitoring.core.logger_config import get_logger

logger = get_logger(__name__)


class SeverityLevel(Enum):
    """Security severity levels."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


class ComplianceStandard(Enum):
    """Supported compliance standards."""
    OWASP_TOP_10 = "OWASP_TOP_10"
    NIST_800_53 = "NIST_800_53"
    ISO_27001 = "ISO_27001"
    PCI_DSS = "PCI_DSS"
    GDPR = "GDPR"
    HIPAA = "HIPAA"


@dataclass
class VulnerabilityReport:
    """Comprehensive vulnerability assessment report."""
    scan_id: str
    timestamp: datetime
    target_path: str
    vulnerabilities: list[dict[str, Any]] = field(default_factory=list)
    compliance_checks: list[dict[str, Any]] = field(default_factory=list)
    risk_score: float = 0.0
    recommendations: list[str] = field(default_factory=list)
    scan_duration: float = 0.0
    scan_status: str = "pending"

    @property
    def valid(self) -> bool:
        """Standardized validity check for Unified Streamline."""
        return self.scan_status == "completed" and self.risk_score < 70.0

    def to_dict(self) -> dict[str, Any]:
        """Convert report to dictionary format."""
        return {
            "scan_id": self.scan_id,
            "timestamp": self.timestamp.isoformat(),
            "target_path": self.target_path,
            "vulnerabilities": self.vulnerabilities,
            "compliance_checks": self.compliance_checks,
            "risk_score": self.risk_score,
            "recommendations": self.recommendations,
            "scan_duration": self.scan_duration,
            "scan_status": self.scan_status,
            "valid": self.valid,
        }


@dataclass
class SecurityScanResult:
    """Results from a security scan operation."""
    component: str
    scan_type: str
    findings: list[dict[str, Any]]
    passed: bool
    timestamp: datetime
    details: dict[str, Any] = field(default_factory=dict)

    @property
    def valid(self) -> bool:
        """Alias for passed to maintain Unified Streamline consistency."""
        return self.passed


@dataclass
class ComplianceCheck:
    """Compliance verification result."""
    standard: str
    requirement: str
    status: str
    evidence: str
    remediation: str | None = None
    timestamp: datetime = field(default_factory=lambda: datetime.now(UTC))


class VulnerabilityScanner:
    """Comprehensive vulnerability scanner for code and dependencies."""

    def __init__(self, config_path: str | None = None):
        """Initialize the vulnerability scanner."""
        self.config_path = config_path or os.path.join(os.getcwd(), "security_config.json")
        self.config = self._load_config()
        self.scan_results: list[VulnerabilityReport] = []

    def _load_config(self) -> dict[str, Any]:
        """Load scanner configuration."""
        default_config = {
            "scan_types": ["dependencies", "code", "compliance"],
            "severity_threshold": "MEDIUM",
            "compliance_standards": ["OWASP_TOP_10"],
            "exclude_patterns": ["*.pyc", "__pycache__/*", ".git/*"],
            "max_scan_time": 300,
            "parallel_scans": True,
            "cache_results": True,
            "cache_ttl": 3600,
        }

        if os.path.exists(self.config_path):
            try:
                with open(self.config_path) as f:
                    user_config = json.load(f)
                default_config.update(user_config)
            except Exception as e:
                logger.warning(f"Failed to load config: {e}")

        return default_config

    def scan_vulnerabilities(
        self, target_path: str, scan_types: list[str] | None = None
    ) -> VulnerabilityReport:
        """Perform comprehensive vulnerability scan."""
        scan_id = self._generate_scan_id(target_path)
        start_time = datetime.now(UTC)

        logger.info(f"Starting vulnerability scan {scan_id} for {target_path}")

        if scan_types is None:
            scan_types = self.config.get("scan_types", ["dependencies", "code"])

        report = VulnerabilityReport(
            scan_id=scan_id,
            timestamp=start_time,
            target_path=target_path,
            scan_status="running",
        )

        try:
            if "dependencies" in scan_types:
                report.vulnerabilities.extend(self._scan_dependencies(target_path))

            if "code" in scan_types:
                report.vulnerabilities.extend(self._scan_code_security(target_path))

            if "compliance" in scan_types:
                report.compliance_checks.extend(self._check_compliance(target_path))

            report.risk_score = self._calculate_risk_score(report.vulnerabilities)
            report.recommendations = self._generate_recommendations(report.vulnerabilities)

            end_time = datetime.now(UTC)
            report.scan_duration = (end_time - start_time).total_seconds()
            report.scan_status = "completed"

            self.scan_results.append(report)
            logger.info(f"Vulnerability scan {scan_id} completed in {report.scan_duration:.2f}s")

        except Exception as e:
            logger.error(f"Vulnerability scan {scan_id} failed: {e}")
            report.scan_status = "failed"
            report.recommendations.append(f"Scan failed: {str(e)}")

        return report

    def _scan_dependencies(self, target_path: str) -> list[dict[str, Any]]:
        """Scan dependencies for vulnerabilities."""
        vulnerabilities = []
        if self._is_python_project(target_path):
            vulnerabilities.extend(self._scan_python_dependencies(target_path))
        if self._is_nodejs_project(target_path):
            vulnerabilities.extend(self._scan_nodejs_dependencies(target_path))
        return vulnerabilities

    def _scan_python_dependencies(self, target_path: str) -> list[dict[str, Any]]:
        """Scan Python dependencies for known CVEs using pip-audit."""
        import shutil
        import subprocess

        vulnerabilities: list[dict[str, Any]] = []

        if not shutil.which("pip-audit"):
            logger.warning("pip-audit not found — skipping Python dependency scan. Install with: pip install pip-audit")
            return vulnerabilities

        try:
            result = subprocess.run(
                ["pip-audit", "--format=json", "--progress-spinner=off"],
                capture_output=True,
                text=True,
                timeout=120,
                cwd=target_path,
            )
            if result.returncode == 0 or result.returncode == 1:  # 1 = vulnerabilities found
                data = json.loads(result.stdout) if result.stdout.strip() else {}
                for dep in data.get("dependencies", []):
                    for vuln in dep.get("vulns", []):
                        vulnerabilities.append({
                            "package": dep.get("name", "unknown"),
                            "version": dep.get("version", "unknown"),
                            "cve": vuln.get("id", "unknown"),
                            "severity": "HIGH",
                            "description": vuln.get("description", ""),
                            "fix_versions": vuln.get("fix_versions", []),
                            "source": "pip-audit",
                        })
        except subprocess.TimeoutExpired:
            logger.warning("pip-audit timed out after 120s")
        except (json.JSONDecodeError, KeyError) as e:
            logger.warning(f"pip-audit output parsing failed: {e}")
        except OSError as e:
            logger.warning(f"pip-audit execution failed: {e}")

        return vulnerabilities

    def _scan_nodejs_dependencies(self, target_path: str) -> list[dict[str, Any]]:
        """Scan Node.js dependencies for known CVEs.

        Raises:
            NotImplementedError: Real dependency scanning is not yet implemented.
                Use the ``static_analysis`` module or run ``npm audit`` externally.
        """
        raise NotImplementedError(
            "_scan_nodejs_dependencies: real CVE scanning not yet implemented. "
            "Run 'npm audit' externally."
        )

    def _scan_code_security(self, target_path: str) -> list[dict[str, Any]]:
        """Scan code for security vulnerabilities using bandit."""
        import shutil
        import subprocess

        vulnerabilities: list[dict[str, Any]] = []

        if not shutil.which("bandit"):
            logger.warning("bandit not found — skipping code security scan. Install with: pip install bandit")
            return vulnerabilities

        try:
            result = subprocess.run(
                ["bandit", "-r", target_path, "-f", "json", "-q"],
                capture_output=True,
                text=True,
                timeout=120,
            )
            if result.stdout.strip():
                data = json.loads(result.stdout)
                severity_map = {"HIGH": "HIGH", "MEDIUM": "MEDIUM", "LOW": "LOW"}
                for issue in data.get("results", []):
                    vulnerabilities.append({
                        "file": issue.get("filename", ""),
                        "line": issue.get("line_number", 0),
                        "severity": severity_map.get(issue.get("issue_severity", "LOW"), "LOW"),
                        "confidence": issue.get("issue_confidence", "LOW"),
                        "test_id": issue.get("test_id", ""),
                        "description": issue.get("issue_text", ""),
                        "source": "bandit",
                    })
        except subprocess.TimeoutExpired:
            logger.warning("bandit timed out after 120s")
        except (json.JSONDecodeError, KeyError) as e:
            logger.warning(f"bandit output parsing failed: {e}")
        except OSError as e:
            logger.warning(f"bandit execution failed: {e}")

        return vulnerabilities

    def _check_compliance(self, target_path: str) -> list[dict[str, Any]]:
        """Check compliance with security standards."""
        results = []
        standards = self.config.get("compliance_standards", ["OWASP_TOP_10"])
        for standard in standards:
            if standard == "OWASP_TOP_10":
                results.extend(self._check_owasp_compliance(target_path))
        return results

    def _check_owasp_compliance(self, target_path: str) -> list[dict[str, Any]]:
        """Check OWASP Top 10 compliance."""
        return [
            {
                "standard": "OWASP_TOP_10",
                "requirement": "A01:2021 - Broken Access Control",
                "status": "not_checked",
                "evidence": "Manual review required",
                "remediation": "Implement proper access control mechanisms",
            },
            {
                "standard": "OWASP_TOP_10",
                "requirement": "A02:2021 - Cryptographic Failures",
                "status": "not_checked",
                "evidence": "Check for proper encryption usage",
                "remediation": "Use strong encryption algorithms",
            }
        ]

    def _calculate_risk_score(self, vulnerabilities: list[dict[str, Any]]) -> float:
        """Calculate overall risk score."""
        if not vulnerabilities:
            return 0.0

        severity_weights = {
            "CRITICAL": 1.0, "HIGH": 0.8, "MEDIUM": 0.6, "LOW": 0.3, "INFO": 0.1
        }

        total_score = sum(severity_weights.get(v.get("severity", "UNKNOWN").upper(), 0.5) for v in vulnerabilities)
        return min(100.0, total_score * 10)

    def _generate_recommendations(self, vulnerabilities: list[dict[str, Any]]) -> list[str]:
        """Generate recommendations."""
        if not vulnerabilities:
            return ["✅ No security vulnerabilities found - continue monitoring"]

        return [f"Found {len(vulnerabilities)} vulnerabilities - review required"]

    def _generate_scan_id(self, target_path: str) -> str:
        """Generate unique scan ID."""
        timestamp = datetime.now(UTC).isoformat()
        path_hash = hashlib.md5(target_path.encode()).hexdigest()[:8]
        return f"scan_{path_hash}_{timestamp}"

    def _is_python_project(self, target_path: str) -> bool:
        """Check if target is a Python project."""
        return any(os.path.exists(os.path.join(target_path, f)) for f in ["requirements.txt", "setup.py", "pyproject.toml"])

    def _is_nodejs_project(self, target_path: str) -> bool:
        """Check if target is a Node.js project."""
        return any(os.path.exists(os.path.join(target_path, f)) for f in ["package.json", "package-lock.json"])


# Convenience functions
def scan_vulnerabilities(target_path: str, scan_types: list[str] | None = None) -> VulnerabilityReport:
    """Convenience function to scan vulnerabilities."""
    scanner = VulnerabilityScanner()
    return scanner.scan_vulnerabilities(target_path, scan_types)

def audit_code_security(target_path: str) -> list[dict[str, Any]]:
    """Convenience function for code security auditing."""
    scanner = VulnerabilityScanner()
    report = scanner.scan_vulnerabilities(target_path, ["code"])
    return report.vulnerabilities

def check_compliance(target_path: str, standards: list[str] | None = None) -> list[dict[str, Any]]:
    """Convenience function for compliance checking."""
    scanner = VulnerabilityScanner()
    if standards:
        scanner.config["compliance_standards"] = standards
    report = scanner.scan_vulnerabilities(target_path, ["compliance"])
    return report.compliance_checks
