"""Trust gateway for PAI ↔ Codomyrmex MCP tool access control.

Implements a three-tier trust model: UNTRUSTED → VERIFIED → TRUSTED.

- ``/codomyrmexVerify`` audits capabilities and promotes safe tools to VERIFIED.
- ``/codomyrmexTrust`` promotes destructive tools to TRUSTED for execution.

Example::

    from codomyrmex.agents.pai.trust_gateway import (
        verify_capabilities,
        trust_tool,
        trusted_call_tool,
    )

    report = verify_capabilities()       # audit everything
    trust_tool("codomyrmex.write_file")  # enable writes
    result = trusted_call_tool("codomyrmex.write_file", path="x.py", content="...")
"""

from __future__ import annotations

import collections
import enum
import hashlib
import json
import logging
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Callable, TypedDict

import threading

from codomyrmex.agents.pai.mcp_bridge import (
    _PROMPT_DEFINITIONS,
    _RESOURCE_DEFINITIONS,
    call_tool,
    create_codomyrmex_mcp_server,
    get_tool_registry,
    invalidate_tool_cache,
    _discover_dynamic_tools,
)
from codomyrmex.logging_monitoring import get_logger
from codomyrmex.model_context_protocol.validation import validate_tool_arguments

logger = get_logger(__name__)
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg is not None:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result


# =====================================================================
# Trust Model
# =====================================================================

class TrustLevel(enum.Enum):
    """Trust tier for an MCP tool."""

    UNTRUSTED = "untrusted"
    VERIFIED = "verified"
    TRUSTED = "trusted"


class SecurityError(Exception):
    """Raised when a security policy is violated."""
    pass


# Global Trust State
_trust_level: TrustLevel = TrustLevel.UNTRUSTED


# Tools that can mutate state — require explicit TRUSTED promotion.
DESTRUCTIVE_TOOLS: frozenset[str] = frozenset({
    "codomyrmex.write_file",
    "codomyrmex.run_command",
    "codomyrmex.run_tests",
    "codomyrmex.call_module_function",
})

# Audit Log
_AUDIT_LOG_MAX_SIZE = 10000
_audit_log: collections.deque = collections.deque(maxlen=_AUDIT_LOG_MAX_SIZE)
_audit_lock = threading.Lock()

# Confirmation
_REQUIRE_CONFIRMATION: bool = False
_pending_confirmations: dict[str, dict[str, Any]] = {}
_CONFIRMATION_TTL = 60.0  # seconds


class AuditEntry(TypedDict):
    timestamp: str
    tool_name: str
    args_hash: str
    result_status: str  # "success" | "error" | "blocked"
    trust_level: str
    duration_ms: float
    error_code: str | None


def x__log_audit_entry__mutmut_orig(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_1(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = None
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_2(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(None, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_3(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=None)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_4(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_5(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, )
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_6(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=False)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_7(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = None
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_8(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(None).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_9(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = None

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_10(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "XXunhashableXX"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_11(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "UNHASHABLE"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_12(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = None

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_13(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "XXtimestampXX": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_14(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "TIMESTAMP": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_15(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(None).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_16(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "XXtool_nameXX": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_17(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "TOOL_NAME": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_18(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "XXargs_hashXX": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_19(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "ARGS_HASH": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_20(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "XXresult_statusXX": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_21(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "RESULT_STATUS": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_22(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "XXtrust_levelXX": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_23(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "TRUST_LEVEL": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_24(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "XXduration_msXX": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_25(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "DURATION_MS": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_26(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "XXerror_codeXX": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_27(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "ERROR_CODE": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_28(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(None).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(entry)


def x__log_audit_entry__mutmut_29(
    tool_name: str,
    args: dict[str, Any],
    status: str,
    trust_level: str,
    duration_ms: float,
    error: Exception | None = None
) -> None:
    """Record an entry in the audit log."""
    # Canonicalize args for consistent hashing
    try:
        args_json = json.dumps(args, sort_keys=True)
        args_hash = hashlib.sha256(args_json.encode()).hexdigest()
    except Exception:
        args_hash = "unhashable"

    entry: AuditEntry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "tool_name": tool_name,
        "args_hash": args_hash,
        "result_status": status,
        "trust_level": trust_level,
        "duration_ms": duration_ms,
        "error_code": type(error).__name__ if error else None,
    }

    with _audit_lock:
        _audit_log.append(None)

x__log_audit_entry__mutmut_mutants : ClassVar[MutantDict] = {
'x__log_audit_entry__mutmut_1': x__log_audit_entry__mutmut_1, 
    'x__log_audit_entry__mutmut_2': x__log_audit_entry__mutmut_2, 
    'x__log_audit_entry__mutmut_3': x__log_audit_entry__mutmut_3, 
    'x__log_audit_entry__mutmut_4': x__log_audit_entry__mutmut_4, 
    'x__log_audit_entry__mutmut_5': x__log_audit_entry__mutmut_5, 
    'x__log_audit_entry__mutmut_6': x__log_audit_entry__mutmut_6, 
    'x__log_audit_entry__mutmut_7': x__log_audit_entry__mutmut_7, 
    'x__log_audit_entry__mutmut_8': x__log_audit_entry__mutmut_8, 
    'x__log_audit_entry__mutmut_9': x__log_audit_entry__mutmut_9, 
    'x__log_audit_entry__mutmut_10': x__log_audit_entry__mutmut_10, 
    'x__log_audit_entry__mutmut_11': x__log_audit_entry__mutmut_11, 
    'x__log_audit_entry__mutmut_12': x__log_audit_entry__mutmut_12, 
    'x__log_audit_entry__mutmut_13': x__log_audit_entry__mutmut_13, 
    'x__log_audit_entry__mutmut_14': x__log_audit_entry__mutmut_14, 
    'x__log_audit_entry__mutmut_15': x__log_audit_entry__mutmut_15, 
    'x__log_audit_entry__mutmut_16': x__log_audit_entry__mutmut_16, 
    'x__log_audit_entry__mutmut_17': x__log_audit_entry__mutmut_17, 
    'x__log_audit_entry__mutmut_18': x__log_audit_entry__mutmut_18, 
    'x__log_audit_entry__mutmut_19': x__log_audit_entry__mutmut_19, 
    'x__log_audit_entry__mutmut_20': x__log_audit_entry__mutmut_20, 
    'x__log_audit_entry__mutmut_21': x__log_audit_entry__mutmut_21, 
    'x__log_audit_entry__mutmut_22': x__log_audit_entry__mutmut_22, 
    'x__log_audit_entry__mutmut_23': x__log_audit_entry__mutmut_23, 
    'x__log_audit_entry__mutmut_24': x__log_audit_entry__mutmut_24, 
    'x__log_audit_entry__mutmut_25': x__log_audit_entry__mutmut_25, 
    'x__log_audit_entry__mutmut_26': x__log_audit_entry__mutmut_26, 
    'x__log_audit_entry__mutmut_27': x__log_audit_entry__mutmut_27, 
    'x__log_audit_entry__mutmut_28': x__log_audit_entry__mutmut_28, 
    'x__log_audit_entry__mutmut_29': x__log_audit_entry__mutmut_29
}

def _log_audit_entry(*args, **kwargs):
    result = _mutmut_trampoline(x__log_audit_entry__mutmut_orig, x__log_audit_entry__mutmut_mutants, args, kwargs)
    return result 

_log_audit_entry.__signature__ = _mutmut_signature(x__log_audit_entry__mutmut_orig)
x__log_audit_entry__mutmut_orig.__name__ = 'x__log_audit_entry'


def x_set_require_confirmation__mutmut_orig(enabled: bool) -> None:
    """Enable or disable confirmation requirement for destructive tools."""
    global _REQUIRE_CONFIRMATION
    _REQUIRE_CONFIRMATION = enabled


def x_set_require_confirmation__mutmut_1(enabled: bool) -> None:
    """Enable or disable confirmation requirement for destructive tools."""
    global _REQUIRE_CONFIRMATION
    _REQUIRE_CONFIRMATION = None

x_set_require_confirmation__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_require_confirmation__mutmut_1': x_set_require_confirmation__mutmut_1
}

def set_require_confirmation(*args, **kwargs):
    result = _mutmut_trampoline(x_set_require_confirmation__mutmut_orig, x_set_require_confirmation__mutmut_mutants, args, kwargs)
    return result 

set_require_confirmation.__signature__ = _mutmut_signature(x_set_require_confirmation__mutmut_orig)
x_set_require_confirmation__mutmut_orig.__name__ = 'x_set_require_confirmation'


def x__cleanup_expired_confirmations__mutmut_orig() -> None:
    """Remove expired confirmation tokens."""
    now = time.monotonic()
    expired = [
        token for token, data in _pending_confirmations.items()
        if now - data["timestamp"] > _CONFIRMATION_TTL
    ]
    for token in expired:
        del _pending_confirmations[token]


def x__cleanup_expired_confirmations__mutmut_1() -> None:
    """Remove expired confirmation tokens."""
    now = None
    expired = [
        token for token, data in _pending_confirmations.items()
        if now - data["timestamp"] > _CONFIRMATION_TTL
    ]
    for token in expired:
        del _pending_confirmations[token]


def x__cleanup_expired_confirmations__mutmut_2() -> None:
    """Remove expired confirmation tokens."""
    now = time.monotonic()
    expired = None
    for token in expired:
        del _pending_confirmations[token]


def x__cleanup_expired_confirmations__mutmut_3() -> None:
    """Remove expired confirmation tokens."""
    now = time.monotonic()
    expired = [
        token for token, data in _pending_confirmations.items()
        if now + data["timestamp"] > _CONFIRMATION_TTL
    ]
    for token in expired:
        del _pending_confirmations[token]


def x__cleanup_expired_confirmations__mutmut_4() -> None:
    """Remove expired confirmation tokens."""
    now = time.monotonic()
    expired = [
        token for token, data in _pending_confirmations.items()
        if now - data["XXtimestampXX"] > _CONFIRMATION_TTL
    ]
    for token in expired:
        del _pending_confirmations[token]


def x__cleanup_expired_confirmations__mutmut_5() -> None:
    """Remove expired confirmation tokens."""
    now = time.monotonic()
    expired = [
        token for token, data in _pending_confirmations.items()
        if now - data["TIMESTAMP"] > _CONFIRMATION_TTL
    ]
    for token in expired:
        del _pending_confirmations[token]


def x__cleanup_expired_confirmations__mutmut_6() -> None:
    """Remove expired confirmation tokens."""
    now = time.monotonic()
    expired = [
        token for token, data in _pending_confirmations.items()
        if now - data["timestamp"] >= _CONFIRMATION_TTL
    ]
    for token in expired:
        del _pending_confirmations[token]

x__cleanup_expired_confirmations__mutmut_mutants : ClassVar[MutantDict] = {
'x__cleanup_expired_confirmations__mutmut_1': x__cleanup_expired_confirmations__mutmut_1, 
    'x__cleanup_expired_confirmations__mutmut_2': x__cleanup_expired_confirmations__mutmut_2, 
    'x__cleanup_expired_confirmations__mutmut_3': x__cleanup_expired_confirmations__mutmut_3, 
    'x__cleanup_expired_confirmations__mutmut_4': x__cleanup_expired_confirmations__mutmut_4, 
    'x__cleanup_expired_confirmations__mutmut_5': x__cleanup_expired_confirmations__mutmut_5, 
    'x__cleanup_expired_confirmations__mutmut_6': x__cleanup_expired_confirmations__mutmut_6
}

def _cleanup_expired_confirmations(*args, **kwargs):
    result = _mutmut_trampoline(x__cleanup_expired_confirmations__mutmut_orig, x__cleanup_expired_confirmations__mutmut_mutants, args, kwargs)
    return result 

_cleanup_expired_confirmations.__signature__ = _mutmut_signature(x__cleanup_expired_confirmations__mutmut_orig)
x__cleanup_expired_confirmations__mutmut_orig.__name__ = 'x__cleanup_expired_confirmations'


def x_get_audit_log__mutmut_orig(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_1(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_2(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any(None):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_3(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(None)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_4(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = None
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_5(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name or entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_6(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["XXtool_nameXX"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_7(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["TOOL_NAME"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_8(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] == tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_9(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                break
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_10(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status or entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_11(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["XXresult_statusXX"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_12(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["RESULT_STATUS"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_13(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] == status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_14(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                break
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_15(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = None
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_16(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(None)
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_17(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["XXtimestampXX"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_18(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["TIMESTAMP"])
                if entry_dt < since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_19(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt <= since:
                    continue
            results.append(entry)
        return results


def x_get_audit_log__mutmut_20(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    break
            results.append(entry)
        return results


def x_get_audit_log__mutmut_21(
    since: datetime | None = None,
    tool_name: str | None = None,
    status: str | None = None
) -> list[AuditEntry]:
    """Retrieve filtered audit log entries."""
    with _audit_lock:
        # fast path if no filters
        if not any((since, tool_name, status)):
            return list(_audit_log)
        
        results = []
        for entry in _audit_log:
            if tool_name and entry["tool_name"] != tool_name:
                continue
            if status and entry["result_status"] != status:
                continue
            if since:
                entry_dt = datetime.fromisoformat(entry["timestamp"])
                if entry_dt < since:
                    continue
            results.append(None)
        return results

x_get_audit_log__mutmut_mutants : ClassVar[MutantDict] = {
'x_get_audit_log__mutmut_1': x_get_audit_log__mutmut_1, 
    'x_get_audit_log__mutmut_2': x_get_audit_log__mutmut_2, 
    'x_get_audit_log__mutmut_3': x_get_audit_log__mutmut_3, 
    'x_get_audit_log__mutmut_4': x_get_audit_log__mutmut_4, 
    'x_get_audit_log__mutmut_5': x_get_audit_log__mutmut_5, 
    'x_get_audit_log__mutmut_6': x_get_audit_log__mutmut_6, 
    'x_get_audit_log__mutmut_7': x_get_audit_log__mutmut_7, 
    'x_get_audit_log__mutmut_8': x_get_audit_log__mutmut_8, 
    'x_get_audit_log__mutmut_9': x_get_audit_log__mutmut_9, 
    'x_get_audit_log__mutmut_10': x_get_audit_log__mutmut_10, 
    'x_get_audit_log__mutmut_11': x_get_audit_log__mutmut_11, 
    'x_get_audit_log__mutmut_12': x_get_audit_log__mutmut_12, 
    'x_get_audit_log__mutmut_13': x_get_audit_log__mutmut_13, 
    'x_get_audit_log__mutmut_14': x_get_audit_log__mutmut_14, 
    'x_get_audit_log__mutmut_15': x_get_audit_log__mutmut_15, 
    'x_get_audit_log__mutmut_16': x_get_audit_log__mutmut_16, 
    'x_get_audit_log__mutmut_17': x_get_audit_log__mutmut_17, 
    'x_get_audit_log__mutmut_18': x_get_audit_log__mutmut_18, 
    'x_get_audit_log__mutmut_19': x_get_audit_log__mutmut_19, 
    'x_get_audit_log__mutmut_20': x_get_audit_log__mutmut_20, 
    'x_get_audit_log__mutmut_21': x_get_audit_log__mutmut_21
}

def get_audit_log(*args, **kwargs):
    result = _mutmut_trampoline(x_get_audit_log__mutmut_orig, x_get_audit_log__mutmut_mutants, args, kwargs)
    return result 

get_audit_log.__signature__ = _mutmut_signature(x_get_audit_log__mutmut_orig)
x_get_audit_log__mutmut_orig.__name__ = 'x_get_audit_log'


def x_export_audit_log__mutmut_orig(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_1(path: str | Path, format: str = "XXjsonlXX") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_2(path: str | Path, format: str = "JSONL") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_3(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = None
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_4(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(None)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_5(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = None
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_6(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format != "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_7(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "XXjsonlXX":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_8(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "JSONL":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_9(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(None, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_10(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, None) as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_11(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open("w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_12(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, ) as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_13(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "XXwXX") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_14(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "W") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_15(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(None)
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_16(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) - "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_17(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(None) + "\n")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_18(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "XX\nXX")
    else:
        raise ValueError(f"Unsupported format: {format}")


def x_export_audit_log__mutmut_19(path: str | Path, format: str = "jsonl") -> None:
    """Export audit log to file."""
    path = Path(path)
    entries = get_audit_log()
    
    if format == "jsonl":
        with open(path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry) + "\n")
    else:
        raise ValueError(None)

x_export_audit_log__mutmut_mutants : ClassVar[MutantDict] = {
'x_export_audit_log__mutmut_1': x_export_audit_log__mutmut_1, 
    'x_export_audit_log__mutmut_2': x_export_audit_log__mutmut_2, 
    'x_export_audit_log__mutmut_3': x_export_audit_log__mutmut_3, 
    'x_export_audit_log__mutmut_4': x_export_audit_log__mutmut_4, 
    'x_export_audit_log__mutmut_5': x_export_audit_log__mutmut_5, 
    'x_export_audit_log__mutmut_6': x_export_audit_log__mutmut_6, 
    'x_export_audit_log__mutmut_7': x_export_audit_log__mutmut_7, 
    'x_export_audit_log__mutmut_8': x_export_audit_log__mutmut_8, 
    'x_export_audit_log__mutmut_9': x_export_audit_log__mutmut_9, 
    'x_export_audit_log__mutmut_10': x_export_audit_log__mutmut_10, 
    'x_export_audit_log__mutmut_11': x_export_audit_log__mutmut_11, 
    'x_export_audit_log__mutmut_12': x_export_audit_log__mutmut_12, 
    'x_export_audit_log__mutmut_13': x_export_audit_log__mutmut_13, 
    'x_export_audit_log__mutmut_14': x_export_audit_log__mutmut_14, 
    'x_export_audit_log__mutmut_15': x_export_audit_log__mutmut_15, 
    'x_export_audit_log__mutmut_16': x_export_audit_log__mutmut_16, 
    'x_export_audit_log__mutmut_17': x_export_audit_log__mutmut_17, 
    'x_export_audit_log__mutmut_18': x_export_audit_log__mutmut_18, 
    'x_export_audit_log__mutmut_19': x_export_audit_log__mutmut_19
}

def export_audit_log(*args, **kwargs):
    result = _mutmut_trampoline(x_export_audit_log__mutmut_orig, x_export_audit_log__mutmut_mutants, args, kwargs)
    return result 

export_audit_log.__signature__ = _mutmut_signature(x_export_audit_log__mutmut_orig)
x_export_audit_log__mutmut_orig.__name__ = 'x_export_audit_log'


def x_clear_audit_log__mutmut_orig(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_1(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is not None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_2(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = None
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_3(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = None
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_4(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = None
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_5(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 1
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_6(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = None
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_7(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = None
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_8(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(None)
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_9(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["XXtimestampXX"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_10(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["TIMESTAMP"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_11(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt <= before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_12(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed = 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_13(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed -= 1
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_14(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 2
            else:
                retained.append(entry)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_15(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(None)
        
        _audit_log.extend(retained)
        return removed


def x_clear_audit_log__mutmut_16(before: datetime | None = None) -> int:
    """Clear audit log entries. Returns count removed."""
    with _audit_lock:
        if before is None:
            count = len(_audit_log)
            _audit_log.clear()
            return count
        
        # Deque doesn't support efficient middle removal, 
        # so we rebuild it.
        retained = []
        removed = 0
        while _audit_log:
            entry = _audit_log.popleft()
            entry_dt = datetime.fromisoformat(entry["timestamp"])
            if entry_dt < before:
                removed += 1
            else:
                retained.append(entry)
        
        _audit_log.extend(None)
        return removed

x_clear_audit_log__mutmut_mutants : ClassVar[MutantDict] = {
'x_clear_audit_log__mutmut_1': x_clear_audit_log__mutmut_1, 
    'x_clear_audit_log__mutmut_2': x_clear_audit_log__mutmut_2, 
    'x_clear_audit_log__mutmut_3': x_clear_audit_log__mutmut_3, 
    'x_clear_audit_log__mutmut_4': x_clear_audit_log__mutmut_4, 
    'x_clear_audit_log__mutmut_5': x_clear_audit_log__mutmut_5, 
    'x_clear_audit_log__mutmut_6': x_clear_audit_log__mutmut_6, 
    'x_clear_audit_log__mutmut_7': x_clear_audit_log__mutmut_7, 
    'x_clear_audit_log__mutmut_8': x_clear_audit_log__mutmut_8, 
    'x_clear_audit_log__mutmut_9': x_clear_audit_log__mutmut_9, 
    'x_clear_audit_log__mutmut_10': x_clear_audit_log__mutmut_10, 
    'x_clear_audit_log__mutmut_11': x_clear_audit_log__mutmut_11, 
    'x_clear_audit_log__mutmut_12': x_clear_audit_log__mutmut_12, 
    'x_clear_audit_log__mutmut_13': x_clear_audit_log__mutmut_13, 
    'x_clear_audit_log__mutmut_14': x_clear_audit_log__mutmut_14, 
    'x_clear_audit_log__mutmut_15': x_clear_audit_log__mutmut_15, 
    'x_clear_audit_log__mutmut_16': x_clear_audit_log__mutmut_16
}

def clear_audit_log(*args, **kwargs):
    result = _mutmut_trampoline(x_clear_audit_log__mutmut_orig, x_clear_audit_log__mutmut_mutants, args, kwargs)
    return result 

clear_audit_log.__signature__ = _mutmut_signature(x_clear_audit_log__mutmut_orig)
x_clear_audit_log__mutmut_orig.__name__ = 'x_clear_audit_log'


# Patterns that indicate a tool may have side effects (for auto-discovered tools).
_DESTRUCTIVE_PATTERNS: frozenset[str] = frozenset({
    "write", "delete", "remove", "execute", "run", "drop",
    "create", "update", "modify", "change", "set", "grant",
    "revoke", "reset", "clear", "kill", "terminate",
})


# Trust Escalation Hooks
_on_trust_change: Callable[[TrustLevel, TrustLevel], None] | None = None


def x_set_trust_change_callback__mutmut_orig(callback: Callable[[TrustLevel, TrustLevel], None] | None) -> None:
    """Set a callback to be invoked when global trust level changes."""
    global _on_trust_change
    _on_trust_change = callback


def x_set_trust_change_callback__mutmut_1(callback: Callable[[TrustLevel, TrustLevel], None] | None) -> None:
    """Set a callback to be invoked when global trust level changes."""
    global _on_trust_change
    _on_trust_change = None

x_set_trust_change_callback__mutmut_mutants : ClassVar[MutantDict] = {
'x_set_trust_change_callback__mutmut_1': x_set_trust_change_callback__mutmut_1
}

def set_trust_change_callback(*args, **kwargs):
    result = _mutmut_trampoline(x_set_trust_change_callback__mutmut_orig, x_set_trust_change_callback__mutmut_mutants, args, kwargs)
    return result 

set_trust_change_callback.__signature__ = _mutmut_signature(x_set_trust_change_callback__mutmut_orig)
x_set_trust_change_callback__mutmut_orig.__name__ = 'x_set_trust_change_callback'


def x__trigger_trust_change__mutmut_orig(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_1(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level != new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_2(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(None, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_3(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, None)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_4(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_5(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, )
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_6(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(None)

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_7(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(None).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_8(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit(None, {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_9(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", None)
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_10(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit({
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_11(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", )
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_12(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("XXTRUST_LEVEL_CHANGEDXX", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_13(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("trust_level_changed", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_14(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "XXold_levelXX": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_15(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "OLD_LEVEL": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_16(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "XXnew_levelXX": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_17(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "NEW_LEVEL": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_18(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "XXtimestampXX": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_19(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "TIMESTAMP": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_20(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(None).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(f"Failed to emit trust event: {e}")


def x__trigger_trust_change__mutmut_21(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(__name__).warning(None)


def x__trigger_trust_change__mutmut_22(old_level: TrustLevel, new_level: TrustLevel) -> None:
    """Invoke callback and emit event on trust change."""
    if old_level == new_level:
        return

    if _on_trust_change:
        try:
            _on_trust_change(old_level, new_level)
        except Exception as e:
            logging.getLogger(__name__).error(f"Trust change callback failed: {e}")

    # Try to emit via EventBus if available
    try:
        from codomyrmex.events import EventBus, EventType
        # TODO(v0.2.0): Use strict EventType.TRUST_LEVEL_CHANGED when available
        EventBus.emit("TRUST_LEVEL_CHANGED", {
            "old_level": old_level.name,
            "new_level": new_level.name,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    except ImportError:
        pass  # EventBus not available in this context
    except Exception as e:
         logging.getLogger(None).warning(f"Failed to emit trust event: {e}")

x__trigger_trust_change__mutmut_mutants : ClassVar[MutantDict] = {
'x__trigger_trust_change__mutmut_1': x__trigger_trust_change__mutmut_1, 
    'x__trigger_trust_change__mutmut_2': x__trigger_trust_change__mutmut_2, 
    'x__trigger_trust_change__mutmut_3': x__trigger_trust_change__mutmut_3, 
    'x__trigger_trust_change__mutmut_4': x__trigger_trust_change__mutmut_4, 
    'x__trigger_trust_change__mutmut_5': x__trigger_trust_change__mutmut_5, 
    'x__trigger_trust_change__mutmut_6': x__trigger_trust_change__mutmut_6, 
    'x__trigger_trust_change__mutmut_7': x__trigger_trust_change__mutmut_7, 
    'x__trigger_trust_change__mutmut_8': x__trigger_trust_change__mutmut_8, 
    'x__trigger_trust_change__mutmut_9': x__trigger_trust_change__mutmut_9, 
    'x__trigger_trust_change__mutmut_10': x__trigger_trust_change__mutmut_10, 
    'x__trigger_trust_change__mutmut_11': x__trigger_trust_change__mutmut_11, 
    'x__trigger_trust_change__mutmut_12': x__trigger_trust_change__mutmut_12, 
    'x__trigger_trust_change__mutmut_13': x__trigger_trust_change__mutmut_13, 
    'x__trigger_trust_change__mutmut_14': x__trigger_trust_change__mutmut_14, 
    'x__trigger_trust_change__mutmut_15': x__trigger_trust_change__mutmut_15, 
    'x__trigger_trust_change__mutmut_16': x__trigger_trust_change__mutmut_16, 
    'x__trigger_trust_change__mutmut_17': x__trigger_trust_change__mutmut_17, 
    'x__trigger_trust_change__mutmut_18': x__trigger_trust_change__mutmut_18, 
    'x__trigger_trust_change__mutmut_19': x__trigger_trust_change__mutmut_19, 
    'x__trigger_trust_change__mutmut_20': x__trigger_trust_change__mutmut_20, 
    'x__trigger_trust_change__mutmut_21': x__trigger_trust_change__mutmut_21, 
    'x__trigger_trust_change__mutmut_22': x__trigger_trust_change__mutmut_22
}

def _trigger_trust_change(*args, **kwargs):
    result = _mutmut_trampoline(x__trigger_trust_change__mutmut_orig, x__trigger_trust_change__mutmut_mutants, args, kwargs)
    return result 

_trigger_trust_change.__signature__ = _mutmut_signature(x__trigger_trust_change__mutmut_orig)
x__trigger_trust_change__mutmut_orig.__name__ = 'x__trigger_trust_change'



def x__is_destructive__mutmut_orig(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = parts[-1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_1(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name not in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = parts[-1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_2(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return False
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = parts[-1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_3(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = None
    if len(parts) >= 3:
        func_name = parts[-1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_4(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(None)
    if len(parts) >= 3:
        func_name = parts[-1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_5(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split("XX.XX")
    if len(parts) >= 3:
        func_name = parts[-1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_6(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) > 3:
        func_name = parts[-1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_7(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 4:
        func_name = parts[-1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_8(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = None
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_9(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = parts[-1].upper()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_10(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = parts[+1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_11(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = parts[-2].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_12(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = parts[-1].lower()
        return any(None)
    return False



def x__is_destructive__mutmut_13(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = parts[-1].lower()
        return any(pattern not in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return False



def x__is_destructive__mutmut_14(tool_name: str) -> bool:
    """Check if an auto-discovered tool name matches destructive patterns."""
    if tool_name in DESTRUCTIVE_TOOLS:
        return True
    # Only apply pattern matching to auto-discovered tools (codomyrmex.module.func)
    parts = tool_name.split(".")
    if len(parts) >= 3:
        func_name = parts[-1].lower()
        return any(pattern in func_name for pattern in _DESTRUCTIVE_PATTERNS)
    return True

x__is_destructive__mutmut_mutants : ClassVar[MutantDict] = {
'x__is_destructive__mutmut_1': x__is_destructive__mutmut_1, 
    'x__is_destructive__mutmut_2': x__is_destructive__mutmut_2, 
    'x__is_destructive__mutmut_3': x__is_destructive__mutmut_3, 
    'x__is_destructive__mutmut_4': x__is_destructive__mutmut_4, 
    'x__is_destructive__mutmut_5': x__is_destructive__mutmut_5, 
    'x__is_destructive__mutmut_6': x__is_destructive__mutmut_6, 
    'x__is_destructive__mutmut_7': x__is_destructive__mutmut_7, 
    'x__is_destructive__mutmut_8': x__is_destructive__mutmut_8, 
    'x__is_destructive__mutmut_9': x__is_destructive__mutmut_9, 
    'x__is_destructive__mutmut_10': x__is_destructive__mutmut_10, 
    'x__is_destructive__mutmut_11': x__is_destructive__mutmut_11, 
    'x__is_destructive__mutmut_12': x__is_destructive__mutmut_12, 
    'x__is_destructive__mutmut_13': x__is_destructive__mutmut_13, 
    'x__is_destructive__mutmut_14': x__is_destructive__mutmut_14
}

def _is_destructive(*args, **kwargs):
    result = _mutmut_trampoline(x__is_destructive__mutmut_orig, x__is_destructive__mutmut_mutants, args, kwargs)
    return result 

_is_destructive.__signature__ = _mutmut_signature(x__is_destructive__mutmut_orig)
x__is_destructive__mutmut_orig.__name__ = 'x__is_destructive'


def x__get_destructive_tools__mutmut_orig() -> frozenset[str]:
    """Get all destructive tool names (explicit + pattern-matched)."""
    registry = get_tool_registry()
    all_names = registry.list_tools()
    return frozenset(name for name in all_names if _is_destructive(name))


def x__get_destructive_tools__mutmut_1() -> frozenset[str]:
    """Get all destructive tool names (explicit + pattern-matched)."""
    registry = None
    all_names = registry.list_tools()
    return frozenset(name for name in all_names if _is_destructive(name))


def x__get_destructive_tools__mutmut_2() -> frozenset[str]:
    """Get all destructive tool names (explicit + pattern-matched)."""
    registry = get_tool_registry()
    all_names = None
    return frozenset(name for name in all_names if _is_destructive(name))


def x__get_destructive_tools__mutmut_3() -> frozenset[str]:
    """Get all destructive tool names (explicit + pattern-matched)."""
    registry = get_tool_registry()
    all_names = registry.list_tools()
    return frozenset(None)


def x__get_destructive_tools__mutmut_4() -> frozenset[str]:
    """Get all destructive tool names (explicit + pattern-matched)."""
    registry = get_tool_registry()
    all_names = registry.list_tools()
    return frozenset(name for name in all_names if _is_destructive(None))

x__get_destructive_tools__mutmut_mutants : ClassVar[MutantDict] = {
'x__get_destructive_tools__mutmut_1': x__get_destructive_tools__mutmut_1, 
    'x__get_destructive_tools__mutmut_2': x__get_destructive_tools__mutmut_2, 
    'x__get_destructive_tools__mutmut_3': x__get_destructive_tools__mutmut_3, 
    'x__get_destructive_tools__mutmut_4': x__get_destructive_tools__mutmut_4
}

def _get_destructive_tools(*args, **kwargs):
    result = _mutmut_trampoline(x__get_destructive_tools__mutmut_orig, x__get_destructive_tools__mutmut_mutants, args, kwargs)
    return result 

_get_destructive_tools.__signature__ = _mutmut_signature(x__get_destructive_tools__mutmut_orig)
x__get_destructive_tools__mutmut_orig.__name__ = 'x__get_destructive_tools'


def x__get_safe_tools__mutmut_orig() -> frozenset[str]:
    """Get all safe tool names (static + dynamic, minus destructive)."""
    registry = get_tool_registry()
    all_names = frozenset(registry.list_tools())
    return all_names - _get_destructive_tools()


def x__get_safe_tools__mutmut_1() -> frozenset[str]:
    """Get all safe tool names (static + dynamic, minus destructive)."""
    registry = None
    all_names = frozenset(registry.list_tools())
    return all_names - _get_destructive_tools()


def x__get_safe_tools__mutmut_2() -> frozenset[str]:
    """Get all safe tool names (static + dynamic, minus destructive)."""
    registry = get_tool_registry()
    all_names = None
    return all_names - _get_destructive_tools()


def x__get_safe_tools__mutmut_3() -> frozenset[str]:
    """Get all safe tool names (static + dynamic, minus destructive)."""
    registry = get_tool_registry()
    all_names = frozenset(None)
    return all_names - _get_destructive_tools()


def x__get_safe_tools__mutmut_4() -> frozenset[str]:
    """Get all safe tool names (static + dynamic, minus destructive)."""
    registry = get_tool_registry()
    all_names = frozenset(registry.list_tools())
    return all_names + _get_destructive_tools()

x__get_safe_tools__mutmut_mutants : ClassVar[MutantDict] = {
'x__get_safe_tools__mutmut_1': x__get_safe_tools__mutmut_1, 
    'x__get_safe_tools__mutmut_2': x__get_safe_tools__mutmut_2, 
    'x__get_safe_tools__mutmut_3': x__get_safe_tools__mutmut_3, 
    'x__get_safe_tools__mutmut_4': x__get_safe_tools__mutmut_4
}

def _get_safe_tools(*args, **kwargs):
    result = _mutmut_trampoline(x__get_safe_tools__mutmut_orig, x__get_safe_tools__mutmut_mutants, args, kwargs)
    return result 

_get_safe_tools.__signature__ = _mutmut_signature(x__get_safe_tools__mutmut_orig)
x__get_safe_tools__mutmut_orig.__name__ = 'x__get_safe_tools'



class _LazyToolSets:
    """Non-caching lazy evaluator for tool sets.

    Each access computes fresh from the registry, avoiding
    import-ordering issues with dynamic tool discovery.
    """

    @staticmethod
    def safe_tools() -> frozenset[str]:
        return _get_safe_tools()

    @staticmethod
    def destructive_tools_set() -> frozenset[str]:
        return _get_destructive_tools()


# DEPRECATED(v0.2.0): Module-level names for backward compatibility -- computed lazily. Will be removed in v0.3.0.
class _FrozenSetProxy:
    """Proxy that behaves like a frozenset but delegates to lazy computation."""

    def xǁ_FrozenSetProxyǁ__init____mutmut_orig(self, accessor):
        self._accessor = accessor

    def xǁ_FrozenSetProxyǁ__init____mutmut_1(self, accessor):
        self._accessor = None
    
    xǁ_FrozenSetProxyǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_FrozenSetProxyǁ__init____mutmut_1': xǁ_FrozenSetProxyǁ__init____mutmut_1
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁ_FrozenSetProxyǁ__init____mutmut_orig)
    xǁ_FrozenSetProxyǁ__init____mutmut_orig.__name__ = 'xǁ_FrozenSetProxyǁ__init__'

    def xǁ_FrozenSetProxyǁ__contains____mutmut_orig(self, item):
        return item in self._accessor()

    def xǁ_FrozenSetProxyǁ__contains____mutmut_1(self, item):
        return item not in self._accessor()
    
    xǁ_FrozenSetProxyǁ__contains____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_FrozenSetProxyǁ__contains____mutmut_1': xǁ_FrozenSetProxyǁ__contains____mutmut_1
    }
    
    def __contains__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__contains____mutmut_orig"), object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__contains____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __contains__.__signature__ = _mutmut_signature(xǁ_FrozenSetProxyǁ__contains____mutmut_orig)
    xǁ_FrozenSetProxyǁ__contains____mutmut_orig.__name__ = 'xǁ_FrozenSetProxyǁ__contains__'

    def xǁ_FrozenSetProxyǁ__iter____mutmut_orig(self):
        return iter(self._accessor())

    def xǁ_FrozenSetProxyǁ__iter____mutmut_1(self):
        return iter(None)
    
    xǁ_FrozenSetProxyǁ__iter____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_FrozenSetProxyǁ__iter____mutmut_1': xǁ_FrozenSetProxyǁ__iter____mutmut_1
    }
    
    def __iter__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__iter____mutmut_orig"), object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__iter____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __iter__.__signature__ = _mutmut_signature(xǁ_FrozenSetProxyǁ__iter____mutmut_orig)
    xǁ_FrozenSetProxyǁ__iter____mutmut_orig.__name__ = 'xǁ_FrozenSetProxyǁ__iter__'

    def __len__(self):
        return len(self._accessor())

    def xǁ_FrozenSetProxyǁ__or____mutmut_orig(self, other):
        return self._accessor() | other

    def xǁ_FrozenSetProxyǁ__or____mutmut_1(self, other):
        return self._accessor() & other
    
    xǁ_FrozenSetProxyǁ__or____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_FrozenSetProxyǁ__or____mutmut_1': xǁ_FrozenSetProxyǁ__or____mutmut_1
    }
    
    def __or__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__or____mutmut_orig"), object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__or____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __or__.__signature__ = _mutmut_signature(xǁ_FrozenSetProxyǁ__or____mutmut_orig)
    xǁ_FrozenSetProxyǁ__or____mutmut_orig.__name__ = 'xǁ_FrozenSetProxyǁ__or__'

    def xǁ_FrozenSetProxyǁ__ror____mutmut_orig(self, other):
        return other | self._accessor()

    def xǁ_FrozenSetProxyǁ__ror____mutmut_1(self, other):
        return other & self._accessor()
    
    xǁ_FrozenSetProxyǁ__ror____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_FrozenSetProxyǁ__ror____mutmut_1': xǁ_FrozenSetProxyǁ__ror____mutmut_1
    }
    
    def __ror__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__ror____mutmut_orig"), object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__ror____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __ror__.__signature__ = _mutmut_signature(xǁ_FrozenSetProxyǁ__ror____mutmut_orig)
    xǁ_FrozenSetProxyǁ__ror____mutmut_orig.__name__ = 'xǁ_FrozenSetProxyǁ__ror__'

    def xǁ_FrozenSetProxyǁ__and____mutmut_orig(self, other):
        return self._accessor() & other

    def xǁ_FrozenSetProxyǁ__and____mutmut_1(self, other):
        return self._accessor() | other
    
    xǁ_FrozenSetProxyǁ__and____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_FrozenSetProxyǁ__and____mutmut_1': xǁ_FrozenSetProxyǁ__and____mutmut_1
    }
    
    def __and__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__and____mutmut_orig"), object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__and____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __and__.__signature__ = _mutmut_signature(xǁ_FrozenSetProxyǁ__and____mutmut_orig)
    xǁ_FrozenSetProxyǁ__and____mutmut_orig.__name__ = 'xǁ_FrozenSetProxyǁ__and__'

    def xǁ_FrozenSetProxyǁ__sub____mutmut_orig(self, other):
        return self._accessor() - other

    def xǁ_FrozenSetProxyǁ__sub____mutmut_1(self, other):
        return self._accessor() + other
    
    xǁ_FrozenSetProxyǁ__sub____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_FrozenSetProxyǁ__sub____mutmut_1': xǁ_FrozenSetProxyǁ__sub____mutmut_1
    }
    
    def __sub__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__sub____mutmut_orig"), object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__sub____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __sub__.__signature__ = _mutmut_signature(xǁ_FrozenSetProxyǁ__sub____mutmut_orig)
    xǁ_FrozenSetProxyǁ__sub____mutmut_orig.__name__ = 'xǁ_FrozenSetProxyǁ__sub__'

    def xǁ_FrozenSetProxyǁ__repr____mutmut_orig(self):
        return repr(self._accessor())

    def xǁ_FrozenSetProxyǁ__repr____mutmut_1(self):
        return repr(None)
    
    xǁ_FrozenSetProxyǁ__repr____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_FrozenSetProxyǁ__repr____mutmut_1': xǁ_FrozenSetProxyǁ__repr____mutmut_1
    }
    
    def __repr__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__repr____mutmut_orig"), object.__getattribute__(self, "xǁ_FrozenSetProxyǁ__repr____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __repr__.__signature__ = _mutmut_signature(xǁ_FrozenSetProxyǁ__repr____mutmut_orig)
    xǁ_FrozenSetProxyǁ__repr____mutmut_orig.__name__ = 'xǁ_FrozenSetProxyǁ__repr__'


SAFE_TOOLS = _FrozenSetProxy(_LazyToolSets.safe_tools)


class _LazyInt:
    """Integer proxy that always evaluates fresh from a callable."""

    def xǁ_LazyIntǁ__init____mutmut_orig(self, fn):
        self._fn = fn

    def xǁ_LazyIntǁ__init____mutmut_1(self, fn):
        self._fn = None
    
    xǁ_LazyIntǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__init____mutmut_1': xǁ_LazyIntǁ__init____mutmut_1
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__init____mutmut_orig)
    xǁ_LazyIntǁ__init____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__init__'

    def _get(self):
        return self._fn()

    def xǁ_LazyIntǁ__eq____mutmut_orig(self, other):
        return self._get() == other

    def xǁ_LazyIntǁ__eq____mutmut_1(self, other):
        return self._get() != other
    
    xǁ_LazyIntǁ__eq____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__eq____mutmut_1': xǁ_LazyIntǁ__eq____mutmut_1
    }
    
    def __eq__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__eq____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__eq____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __eq__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__eq____mutmut_orig)
    xǁ_LazyIntǁ__eq____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__eq__'

    def xǁ_LazyIntǁ__ne____mutmut_orig(self, other):
        return self._get() != other

    def xǁ_LazyIntǁ__ne____mutmut_1(self, other):
        return self._get() == other
    
    xǁ_LazyIntǁ__ne____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__ne____mutmut_1': xǁ_LazyIntǁ__ne____mutmut_1
    }
    
    def __ne__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__ne____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__ne____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __ne__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__ne____mutmut_orig)
    xǁ_LazyIntǁ__ne____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__ne__'

    def xǁ_LazyIntǁ__lt____mutmut_orig(self, other):
        return self._get() < other

    def xǁ_LazyIntǁ__lt____mutmut_1(self, other):
        return self._get() <= other
    
    xǁ_LazyIntǁ__lt____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__lt____mutmut_1': xǁ_LazyIntǁ__lt____mutmut_1
    }
    
    def __lt__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__lt____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__lt____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __lt__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__lt____mutmut_orig)
    xǁ_LazyIntǁ__lt____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__lt__'

    def xǁ_LazyIntǁ__gt____mutmut_orig(self, other):
        return self._get() > other

    def xǁ_LazyIntǁ__gt____mutmut_1(self, other):
        return self._get() >= other
    
    xǁ_LazyIntǁ__gt____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__gt____mutmut_1': xǁ_LazyIntǁ__gt____mutmut_1
    }
    
    def __gt__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__gt____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__gt____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __gt__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__gt____mutmut_orig)
    xǁ_LazyIntǁ__gt____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__gt__'

    def xǁ_LazyIntǁ__le____mutmut_orig(self, other):
        return self._get() <= other

    def xǁ_LazyIntǁ__le____mutmut_1(self, other):
        return self._get() < other
    
    xǁ_LazyIntǁ__le____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__le____mutmut_1': xǁ_LazyIntǁ__le____mutmut_1
    }
    
    def __le__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__le____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__le____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __le__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__le____mutmut_orig)
    xǁ_LazyIntǁ__le____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__le__'

    def xǁ_LazyIntǁ__ge____mutmut_orig(self, other):
        return self._get() >= other

    def xǁ_LazyIntǁ__ge____mutmut_1(self, other):
        return self._get() > other
    
    xǁ_LazyIntǁ__ge____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__ge____mutmut_1': xǁ_LazyIntǁ__ge____mutmut_1
    }
    
    def __ge__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__ge____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__ge____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __ge__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__ge____mutmut_orig)
    xǁ_LazyIntǁ__ge____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__ge__'

    def xǁ_LazyIntǁ__add____mutmut_orig(self, other):
        return self._get() + (other._get() if isinstance(other, _LazyInt) else other)

    def xǁ_LazyIntǁ__add____mutmut_1(self, other):
        return self._get() - (other._get() if isinstance(other, _LazyInt) else other)
    
    xǁ_LazyIntǁ__add____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__add____mutmut_1': xǁ_LazyIntǁ__add____mutmut_1
    }
    
    def __add__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__add____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__add____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __add__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__add____mutmut_orig)
    xǁ_LazyIntǁ__add____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__add__'

    def xǁ_LazyIntǁ__radd____mutmut_orig(self, other):
        return other + self._get()

    def xǁ_LazyIntǁ__radd____mutmut_1(self, other):
        return other - self._get()
    
    xǁ_LazyIntǁ__radd____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__radd____mutmut_1': xǁ_LazyIntǁ__radd____mutmut_1
    }
    
    def __radd__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__radd____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__radd____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __radd__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__radd____mutmut_orig)
    xǁ_LazyIntǁ__radd____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__radd__'

    def xǁ_LazyIntǁ__sub____mutmut_orig(self, other):
        return self._get() - (other._get() if isinstance(other, _LazyInt) else other)

    def xǁ_LazyIntǁ__sub____mutmut_1(self, other):
        return self._get() + (other._get() if isinstance(other, _LazyInt) else other)
    
    xǁ_LazyIntǁ__sub____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__sub____mutmut_1': xǁ_LazyIntǁ__sub____mutmut_1
    }
    
    def __sub__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__sub____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__sub____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __sub__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__sub____mutmut_orig)
    xǁ_LazyIntǁ__sub____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__sub__'

    def xǁ_LazyIntǁ__rsub____mutmut_orig(self, other):
        return other - self._get()

    def xǁ_LazyIntǁ__rsub____mutmut_1(self, other):
        return other + self._get()
    
    xǁ_LazyIntǁ__rsub____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__rsub____mutmut_1': xǁ_LazyIntǁ__rsub____mutmut_1
    }
    
    def __rsub__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__rsub____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__rsub____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __rsub__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__rsub____mutmut_orig)
    xǁ_LazyIntǁ__rsub____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__rsub__'

    def __int__(self):
        return self._get()

    def xǁ_LazyIntǁ__repr____mutmut_orig(self):
        return repr(self._get())

    def xǁ_LazyIntǁ__repr____mutmut_1(self):
        return repr(None)
    
    xǁ_LazyIntǁ__repr____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__repr____mutmut_1': xǁ_LazyIntǁ__repr____mutmut_1
    }
    
    def __repr__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__repr____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__repr____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __repr__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__repr____mutmut_orig)
    xǁ_LazyIntǁ__repr____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__repr__'

    def xǁ_LazyIntǁ__hash____mutmut_orig(self):
        return hash(self._get())

    def xǁ_LazyIntǁ__hash____mutmut_1(self):
        return hash(None)
    
    xǁ_LazyIntǁ__hash____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_LazyIntǁ__hash____mutmut_1': xǁ_LazyIntǁ__hash____mutmut_1
    }
    
    def __hash__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_LazyIntǁ__hash____mutmut_orig"), object.__getattribute__(self, "xǁ_LazyIntǁ__hash____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __hash__.__signature__ = _mutmut_signature(xǁ_LazyIntǁ__hash____mutmut_orig)
    xǁ_LazyIntǁ__hash____mutmut_orig.__name__ = 'xǁ_LazyIntǁ__hash__'


SAFE_TOOL_COUNT = _LazyInt(lambda: len(_get_safe_tools()))
DESTRUCTIVE_TOOL_COUNT = _LazyInt(lambda: len(_get_destructive_tools()))



class TrustRegistry:
    """In-memory trust ledger for Codomyrmex MCP tools.

    Thread-safe by design (single-process, GIL-protected dict ops).
    """

    def xǁTrustRegistryǁ__init____mutmut_orig(self) -> None:
        self._ledger_path = Path.home() / ".codomyrmex" / "trust_ledger.json"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_1(self) -> None:
        self._ledger_path = None

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_2(self) -> None:
        self._ledger_path = Path.home() / ".codomyrmex" * "trust_ledger.json"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_3(self) -> None:
        self._ledger_path = Path.home() * ".codomyrmex" / "trust_ledger.json"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_4(self) -> None:
        self._ledger_path = Path.home() / "XX.codomyrmexXX" / "trust_ledger.json"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_5(self) -> None:
        self._ledger_path = Path.home() / ".CODOMYRMEX" / "trust_ledger.json"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_6(self) -> None:
        self._ledger_path = Path.home() / ".codomyrmex" / "XXtrust_ledger.jsonXX"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_7(self) -> None:
        self._ledger_path = Path.home() / ".codomyrmex" / "TRUST_LEDGER.JSON"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_8(self) -> None:
        self._ledger_path = Path.home() / ".codomyrmex" / "trust_ledger.json"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = None
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_9(self) -> None:
        self._ledger_path = Path.home() / ".codomyrmex" / "trust_ledger.json"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = None

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_10(self) -> None:
        self._ledger_path = Path.home() / ".codomyrmex" / "trust_ledger.json"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = None
        for name in all_tool_names:
            self._levels[name] = TrustLevel.UNTRUSTED

        # Load persisted state if available
        self._load()

    def xǁTrustRegistryǁ__init____mutmut_11(self) -> None:
        self._ledger_path = Path.home() / ".codomyrmex" / "trust_ledger.json"

        # Initialize default state with ALL known tools (static + dynamic)
        registry = get_tool_registry()
        all_tool_names = registry.list_tools()

        self._levels: dict[str, TrustLevel] = {}
        for name in all_tool_names:
            self._levels[name] = None

        # Load persisted state if available
        self._load()
    
    xǁTrustRegistryǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁ__init____mutmut_1': xǁTrustRegistryǁ__init____mutmut_1, 
        'xǁTrustRegistryǁ__init____mutmut_2': xǁTrustRegistryǁ__init____mutmut_2, 
        'xǁTrustRegistryǁ__init____mutmut_3': xǁTrustRegistryǁ__init____mutmut_3, 
        'xǁTrustRegistryǁ__init____mutmut_4': xǁTrustRegistryǁ__init____mutmut_4, 
        'xǁTrustRegistryǁ__init____mutmut_5': xǁTrustRegistryǁ__init____mutmut_5, 
        'xǁTrustRegistryǁ__init____mutmut_6': xǁTrustRegistryǁ__init____mutmut_6, 
        'xǁTrustRegistryǁ__init____mutmut_7': xǁTrustRegistryǁ__init____mutmut_7, 
        'xǁTrustRegistryǁ__init____mutmut_8': xǁTrustRegistryǁ__init____mutmut_8, 
        'xǁTrustRegistryǁ__init____mutmut_9': xǁTrustRegistryǁ__init____mutmut_9, 
        'xǁTrustRegistryǁ__init____mutmut_10': xǁTrustRegistryǁ__init____mutmut_10, 
        'xǁTrustRegistryǁ__init____mutmut_11': xǁTrustRegistryǁ__init____mutmut_11
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁTrustRegistryǁ__init____mutmut_orig)
    xǁTrustRegistryǁ__init____mutmut_orig.__name__ = 'xǁTrustRegistryǁ__init__'

    def xǁTrustRegistryǁ_load__mutmut_orig(self) -> None:
        """Load trust state from disk."""
        if not self._ledger_path.exists():
            return

        try:
            data = json.loads(self._ledger_path.read_text())
            for name, level_val in data.items():
                if name in self._levels:
                    try:
                        self._levels[name] = TrustLevel(level_val)
                    except ValueError:
                        pass
        except Exception as e:
            logger.warning(f"Failed to load trust ledger: {e}")

    def xǁTrustRegistryǁ_load__mutmut_1(self) -> None:
        """Load trust state from disk."""
        if self._ledger_path.exists():
            return

        try:
            data = json.loads(self._ledger_path.read_text())
            for name, level_val in data.items():
                if name in self._levels:
                    try:
                        self._levels[name] = TrustLevel(level_val)
                    except ValueError:
                        pass
        except Exception as e:
            logger.warning(f"Failed to load trust ledger: {e}")

    def xǁTrustRegistryǁ_load__mutmut_2(self) -> None:
        """Load trust state from disk."""
        if not self._ledger_path.exists():
            return

        try:
            data = None
            for name, level_val in data.items():
                if name in self._levels:
                    try:
                        self._levels[name] = TrustLevel(level_val)
                    except ValueError:
                        pass
        except Exception as e:
            logger.warning(f"Failed to load trust ledger: {e}")

    def xǁTrustRegistryǁ_load__mutmut_3(self) -> None:
        """Load trust state from disk."""
        if not self._ledger_path.exists():
            return

        try:
            data = json.loads(None)
            for name, level_val in data.items():
                if name in self._levels:
                    try:
                        self._levels[name] = TrustLevel(level_val)
                    except ValueError:
                        pass
        except Exception as e:
            logger.warning(f"Failed to load trust ledger: {e}")

    def xǁTrustRegistryǁ_load__mutmut_4(self) -> None:
        """Load trust state from disk."""
        if not self._ledger_path.exists():
            return

        try:
            data = json.loads(self._ledger_path.read_text())
            for name, level_val in data.items():
                if name not in self._levels:
                    try:
                        self._levels[name] = TrustLevel(level_val)
                    except ValueError:
                        pass
        except Exception as e:
            logger.warning(f"Failed to load trust ledger: {e}")

    def xǁTrustRegistryǁ_load__mutmut_5(self) -> None:
        """Load trust state from disk."""
        if not self._ledger_path.exists():
            return

        try:
            data = json.loads(self._ledger_path.read_text())
            for name, level_val in data.items():
                if name in self._levels:
                    try:
                        self._levels[name] = None
                    except ValueError:
                        pass
        except Exception as e:
            logger.warning(f"Failed to load trust ledger: {e}")

    def xǁTrustRegistryǁ_load__mutmut_6(self) -> None:
        """Load trust state from disk."""
        if not self._ledger_path.exists():
            return

        try:
            data = json.loads(self._ledger_path.read_text())
            for name, level_val in data.items():
                if name in self._levels:
                    try:
                        self._levels[name] = TrustLevel(None)
                    except ValueError:
                        pass
        except Exception as e:
            logger.warning(f"Failed to load trust ledger: {e}")

    def xǁTrustRegistryǁ_load__mutmut_7(self) -> None:
        """Load trust state from disk."""
        if not self._ledger_path.exists():
            return

        try:
            data = json.loads(self._ledger_path.read_text())
            for name, level_val in data.items():
                if name in self._levels:
                    try:
                        self._levels[name] = TrustLevel(level_val)
                    except ValueError:
                        pass
        except Exception as e:
            logger.warning(None)
    
    xǁTrustRegistryǁ_load__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁ_load__mutmut_1': xǁTrustRegistryǁ_load__mutmut_1, 
        'xǁTrustRegistryǁ_load__mutmut_2': xǁTrustRegistryǁ_load__mutmut_2, 
        'xǁTrustRegistryǁ_load__mutmut_3': xǁTrustRegistryǁ_load__mutmut_3, 
        'xǁTrustRegistryǁ_load__mutmut_4': xǁTrustRegistryǁ_load__mutmut_4, 
        'xǁTrustRegistryǁ_load__mutmut_5': xǁTrustRegistryǁ_load__mutmut_5, 
        'xǁTrustRegistryǁ_load__mutmut_6': xǁTrustRegistryǁ_load__mutmut_6, 
        'xǁTrustRegistryǁ_load__mutmut_7': xǁTrustRegistryǁ_load__mutmut_7
    }
    
    def _load(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁ_load__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁ_load__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _load.__signature__ = _mutmut_signature(xǁTrustRegistryǁ_load__mutmut_orig)
    xǁTrustRegistryǁ_load__mutmut_orig.__name__ = 'xǁTrustRegistryǁ_load'

    def xǁTrustRegistryǁ_save__mutmut_orig(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_1(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=None, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_2(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=None)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_3(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_4(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, )
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_5(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=False, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_6(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=False)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_7(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=True)
            data = None
            self._ledger_path.write_text(json.dumps(data, indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_8(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(None)
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_9(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(None, indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_10(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=None))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_11(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(indent=2))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_12(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, ))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_13(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=3))
        except Exception as e:
            logger.error(f"Failed to save trust ledger: {e}")

    def xǁTrustRegistryǁ_save__mutmut_14(self) -> None:
        """Save trust state to disk."""
        try:
            self._ledger_path.parent.mkdir(parents=True, exist_ok=True)
            data = {name: lvl.value for name, lvl in self._levels.items()}
            self._ledger_path.write_text(json.dumps(data, indent=2))
        except Exception as e:
            logger.error(None)
    
    xǁTrustRegistryǁ_save__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁ_save__mutmut_1': xǁTrustRegistryǁ_save__mutmut_1, 
        'xǁTrustRegistryǁ_save__mutmut_2': xǁTrustRegistryǁ_save__mutmut_2, 
        'xǁTrustRegistryǁ_save__mutmut_3': xǁTrustRegistryǁ_save__mutmut_3, 
        'xǁTrustRegistryǁ_save__mutmut_4': xǁTrustRegistryǁ_save__mutmut_4, 
        'xǁTrustRegistryǁ_save__mutmut_5': xǁTrustRegistryǁ_save__mutmut_5, 
        'xǁTrustRegistryǁ_save__mutmut_6': xǁTrustRegistryǁ_save__mutmut_6, 
        'xǁTrustRegistryǁ_save__mutmut_7': xǁTrustRegistryǁ_save__mutmut_7, 
        'xǁTrustRegistryǁ_save__mutmut_8': xǁTrustRegistryǁ_save__mutmut_8, 
        'xǁTrustRegistryǁ_save__mutmut_9': xǁTrustRegistryǁ_save__mutmut_9, 
        'xǁTrustRegistryǁ_save__mutmut_10': xǁTrustRegistryǁ_save__mutmut_10, 
        'xǁTrustRegistryǁ_save__mutmut_11': xǁTrustRegistryǁ_save__mutmut_11, 
        'xǁTrustRegistryǁ_save__mutmut_12': xǁTrustRegistryǁ_save__mutmut_12, 
        'xǁTrustRegistryǁ_save__mutmut_13': xǁTrustRegistryǁ_save__mutmut_13, 
        'xǁTrustRegistryǁ_save__mutmut_14': xǁTrustRegistryǁ_save__mutmut_14
    }
    
    def _save(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁ_save__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁ_save__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _save.__signature__ = _mutmut_signature(xǁTrustRegistryǁ_save__mutmut_orig)
    xǁTrustRegistryǁ_save__mutmut_orig.__name__ = 'xǁTrustRegistryǁ_save'

    # ── Queries ───────────────────────────────────────────────────

    def xǁTrustRegistryǁlevel__mutmut_orig(self, tool_name: str) -> TrustLevel:
        """Get the current trust level for *tool_name*."""
        # Reload to ensure we see updates from other processes
        self._load()
        return self._levels.get(tool_name, TrustLevel.UNTRUSTED)

    # ── Queries ───────────────────────────────────────────────────

    def xǁTrustRegistryǁlevel__mutmut_1(self, tool_name: str) -> TrustLevel:
        """Get the current trust level for *tool_name*."""
        # Reload to ensure we see updates from other processes
        self._load()
        return self._levels.get(None, TrustLevel.UNTRUSTED)

    # ── Queries ───────────────────────────────────────────────────

    def xǁTrustRegistryǁlevel__mutmut_2(self, tool_name: str) -> TrustLevel:
        """Get the current trust level for *tool_name*."""
        # Reload to ensure we see updates from other processes
        self._load()
        return self._levels.get(tool_name, None)

    # ── Queries ───────────────────────────────────────────────────

    def xǁTrustRegistryǁlevel__mutmut_3(self, tool_name: str) -> TrustLevel:
        """Get the current trust level for *tool_name*."""
        # Reload to ensure we see updates from other processes
        self._load()
        return self._levels.get(TrustLevel.UNTRUSTED)

    # ── Queries ───────────────────────────────────────────────────

    def xǁTrustRegistryǁlevel__mutmut_4(self, tool_name: str) -> TrustLevel:
        """Get the current trust level for *tool_name*."""
        # Reload to ensure we see updates from other processes
        self._load()
        return self._levels.get(tool_name, )
    
    xǁTrustRegistryǁlevel__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁlevel__mutmut_1': xǁTrustRegistryǁlevel__mutmut_1, 
        'xǁTrustRegistryǁlevel__mutmut_2': xǁTrustRegistryǁlevel__mutmut_2, 
        'xǁTrustRegistryǁlevel__mutmut_3': xǁTrustRegistryǁlevel__mutmut_3, 
        'xǁTrustRegistryǁlevel__mutmut_4': xǁTrustRegistryǁlevel__mutmut_4
    }
    
    def level(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁlevel__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁlevel__mutmut_mutants"), args, kwargs, self)
        return result 
    
    level.__signature__ = _mutmut_signature(xǁTrustRegistryǁlevel__mutmut_orig)
    xǁTrustRegistryǁlevel__mutmut_orig.__name__ = 'xǁTrustRegistryǁlevel'

    # ── Mutations ─────────────────────────────────────────────────

    def xǁTrustRegistryǁverify_all_safe__mutmut_orig(self) -> list[str]:
        """Promote all safe (read-only) tools to VERIFIED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in SAFE_TOOLS:
            if name in self._levels and self._levels[name] == TrustLevel.UNTRUSTED:
                self._levels[name] = TrustLevel.VERIFIED
                promoted.append(name)

        if promoted:
            self._save()

        return sorted(promoted)

    # ── Mutations ─────────────────────────────────────────────────

    def xǁTrustRegistryǁverify_all_safe__mutmut_1(self) -> list[str]:
        """Promote all safe (read-only) tools to VERIFIED. Return promoted names."""
        self._load() # Refresh first
        promoted = None
        for name in SAFE_TOOLS:
            if name in self._levels and self._levels[name] == TrustLevel.UNTRUSTED:
                self._levels[name] = TrustLevel.VERIFIED
                promoted.append(name)

        if promoted:
            self._save()

        return sorted(promoted)

    # ── Mutations ─────────────────────────────────────────────────

    def xǁTrustRegistryǁverify_all_safe__mutmut_2(self) -> list[str]:
        """Promote all safe (read-only) tools to VERIFIED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in SAFE_TOOLS:
            if name in self._levels or self._levels[name] == TrustLevel.UNTRUSTED:
                self._levels[name] = TrustLevel.VERIFIED
                promoted.append(name)

        if promoted:
            self._save()

        return sorted(promoted)

    # ── Mutations ─────────────────────────────────────────────────

    def xǁTrustRegistryǁverify_all_safe__mutmut_3(self) -> list[str]:
        """Promote all safe (read-only) tools to VERIFIED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in SAFE_TOOLS:
            if name not in self._levels and self._levels[name] == TrustLevel.UNTRUSTED:
                self._levels[name] = TrustLevel.VERIFIED
                promoted.append(name)

        if promoted:
            self._save()

        return sorted(promoted)

    # ── Mutations ─────────────────────────────────────────────────

    def xǁTrustRegistryǁverify_all_safe__mutmut_4(self) -> list[str]:
        """Promote all safe (read-only) tools to VERIFIED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in SAFE_TOOLS:
            if name in self._levels and self._levels[name] != TrustLevel.UNTRUSTED:
                self._levels[name] = TrustLevel.VERIFIED
                promoted.append(name)

        if promoted:
            self._save()

        return sorted(promoted)

    # ── Mutations ─────────────────────────────────────────────────

    def xǁTrustRegistryǁverify_all_safe__mutmut_5(self) -> list[str]:
        """Promote all safe (read-only) tools to VERIFIED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in SAFE_TOOLS:
            if name in self._levels and self._levels[name] == TrustLevel.UNTRUSTED:
                self._levels[name] = None
                promoted.append(name)

        if promoted:
            self._save()

        return sorted(promoted)

    # ── Mutations ─────────────────────────────────────────────────

    def xǁTrustRegistryǁverify_all_safe__mutmut_6(self) -> list[str]:
        """Promote all safe (read-only) tools to VERIFIED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in SAFE_TOOLS:
            if name in self._levels and self._levels[name] == TrustLevel.UNTRUSTED:
                self._levels[name] = TrustLevel.VERIFIED
                promoted.append(None)

        if promoted:
            self._save()

        return sorted(promoted)

    # ── Mutations ─────────────────────────────────────────────────

    def xǁTrustRegistryǁverify_all_safe__mutmut_7(self) -> list[str]:
        """Promote all safe (read-only) tools to VERIFIED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in SAFE_TOOLS:
            if name in self._levels and self._levels[name] == TrustLevel.UNTRUSTED:
                self._levels[name] = TrustLevel.VERIFIED
                promoted.append(name)

        if promoted:
            self._save()

        return sorted(None)
    
    xǁTrustRegistryǁverify_all_safe__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁverify_all_safe__mutmut_1': xǁTrustRegistryǁverify_all_safe__mutmut_1, 
        'xǁTrustRegistryǁverify_all_safe__mutmut_2': xǁTrustRegistryǁverify_all_safe__mutmut_2, 
        'xǁTrustRegistryǁverify_all_safe__mutmut_3': xǁTrustRegistryǁverify_all_safe__mutmut_3, 
        'xǁTrustRegistryǁverify_all_safe__mutmut_4': xǁTrustRegistryǁverify_all_safe__mutmut_4, 
        'xǁTrustRegistryǁverify_all_safe__mutmut_5': xǁTrustRegistryǁverify_all_safe__mutmut_5, 
        'xǁTrustRegistryǁverify_all_safe__mutmut_6': xǁTrustRegistryǁverify_all_safe__mutmut_6, 
        'xǁTrustRegistryǁverify_all_safe__mutmut_7': xǁTrustRegistryǁverify_all_safe__mutmut_7
    }
    
    def verify_all_safe(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁverify_all_safe__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁverify_all_safe__mutmut_mutants"), args, kwargs, self)
        return result 
    
    verify_all_safe.__signature__ = _mutmut_signature(xǁTrustRegistryǁverify_all_safe__mutmut_orig)
    xǁTrustRegistryǁverify_all_safe__mutmut_orig.__name__ = 'xǁTrustRegistryǁverify_all_safe'

    def xǁTrustRegistryǁtrust_tool__mutmut_orig(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_1(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_2(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                None
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_3(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(None)}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_4(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = None
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_5(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = None
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_6(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info(None, tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_7(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", None)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_8(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info(tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_9(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", )
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_10(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("XXTool %s promoted to TRUSTEDXX", tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_11(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("tool %s promoted to trusted", tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_12(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("TOOL %S PROMOTED TO TRUSTED", tool_name)
        _trigger_trust_change(old_level, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_13(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(None, TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_14(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(old_level, None)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_15(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(TrustLevel.TRUSTED)
        return TrustLevel.TRUSTED

    def xǁTrustRegistryǁtrust_tool__mutmut_16(self, tool_name: str) -> TrustLevel:
        """Promote *tool_name* to TRUSTED."""
        self._load() # Refresh first
        if tool_name not in self._levels:
            raise KeyError(
                f"Unknown tool: {tool_name!r}. "
                f"Available: {sorted(self._levels.keys())}"
            )
        old_level = self._levels[tool_name]
        self._levels[tool_name] = TrustLevel.TRUSTED
        self._save()
        logger.info("Tool %s promoted to TRUSTED", tool_name)
        _trigger_trust_change(old_level, )
        return TrustLevel.TRUSTED
    
    xǁTrustRegistryǁtrust_tool__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁtrust_tool__mutmut_1': xǁTrustRegistryǁtrust_tool__mutmut_1, 
        'xǁTrustRegistryǁtrust_tool__mutmut_2': xǁTrustRegistryǁtrust_tool__mutmut_2, 
        'xǁTrustRegistryǁtrust_tool__mutmut_3': xǁTrustRegistryǁtrust_tool__mutmut_3, 
        'xǁTrustRegistryǁtrust_tool__mutmut_4': xǁTrustRegistryǁtrust_tool__mutmut_4, 
        'xǁTrustRegistryǁtrust_tool__mutmut_5': xǁTrustRegistryǁtrust_tool__mutmut_5, 
        'xǁTrustRegistryǁtrust_tool__mutmut_6': xǁTrustRegistryǁtrust_tool__mutmut_6, 
        'xǁTrustRegistryǁtrust_tool__mutmut_7': xǁTrustRegistryǁtrust_tool__mutmut_7, 
        'xǁTrustRegistryǁtrust_tool__mutmut_8': xǁTrustRegistryǁtrust_tool__mutmut_8, 
        'xǁTrustRegistryǁtrust_tool__mutmut_9': xǁTrustRegistryǁtrust_tool__mutmut_9, 
        'xǁTrustRegistryǁtrust_tool__mutmut_10': xǁTrustRegistryǁtrust_tool__mutmut_10, 
        'xǁTrustRegistryǁtrust_tool__mutmut_11': xǁTrustRegistryǁtrust_tool__mutmut_11, 
        'xǁTrustRegistryǁtrust_tool__mutmut_12': xǁTrustRegistryǁtrust_tool__mutmut_12, 
        'xǁTrustRegistryǁtrust_tool__mutmut_13': xǁTrustRegistryǁtrust_tool__mutmut_13, 
        'xǁTrustRegistryǁtrust_tool__mutmut_14': xǁTrustRegistryǁtrust_tool__mutmut_14, 
        'xǁTrustRegistryǁtrust_tool__mutmut_15': xǁTrustRegistryǁtrust_tool__mutmut_15, 
        'xǁTrustRegistryǁtrust_tool__mutmut_16': xǁTrustRegistryǁtrust_tool__mutmut_16
    }
    
    def trust_tool(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁtrust_tool__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁtrust_tool__mutmut_mutants"), args, kwargs, self)
        return result 
    
    trust_tool.__signature__ = _mutmut_signature(xǁTrustRegistryǁtrust_tool__mutmut_orig)
    xǁTrustRegistryǁtrust_tool__mutmut_orig.__name__ = 'xǁTrustRegistryǁtrust_tool'

    def xǁTrustRegistryǁtrust_all__mutmut_orig(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("All %d tools promoted to TRUSTED", len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_1(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = None
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("All %d tools promoted to TRUSTED", len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_2(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] == TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("All %d tools promoted to TRUSTED", len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_3(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = None
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("All %d tools promoted to TRUSTED", len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_4(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(None)

        if promoted:
            self._save()

        logger.info("All %d tools promoted to TRUSTED", len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_5(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info(None, len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_6(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("All %d tools promoted to TRUSTED", None)
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_7(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info(len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_8(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("All %d tools promoted to TRUSTED", )
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_9(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("XXAll %d tools promoted to TRUSTEDXX", len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_10(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("all %d tools promoted to trusted", len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_11(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("ALL %D TOOLS PROMOTED TO TRUSTED", len(promoted))
        return sorted(promoted)

    def xǁTrustRegistryǁtrust_all__mutmut_12(self) -> list[str]:
        """Promote **all** tools to TRUSTED. Return promoted names."""
        self._load() # Refresh first
        promoted = []
        for name in self._levels:
            if self._levels[name] != TrustLevel.TRUSTED:
                self._levels[name] = TrustLevel.TRUSTED
                promoted.append(name)

        if promoted:
            self._save()

        logger.info("All %d tools promoted to TRUSTED", len(promoted))
        return sorted(None)
    
    xǁTrustRegistryǁtrust_all__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁtrust_all__mutmut_1': xǁTrustRegistryǁtrust_all__mutmut_1, 
        'xǁTrustRegistryǁtrust_all__mutmut_2': xǁTrustRegistryǁtrust_all__mutmut_2, 
        'xǁTrustRegistryǁtrust_all__mutmut_3': xǁTrustRegistryǁtrust_all__mutmut_3, 
        'xǁTrustRegistryǁtrust_all__mutmut_4': xǁTrustRegistryǁtrust_all__mutmut_4, 
        'xǁTrustRegistryǁtrust_all__mutmut_5': xǁTrustRegistryǁtrust_all__mutmut_5, 
        'xǁTrustRegistryǁtrust_all__mutmut_6': xǁTrustRegistryǁtrust_all__mutmut_6, 
        'xǁTrustRegistryǁtrust_all__mutmut_7': xǁTrustRegistryǁtrust_all__mutmut_7, 
        'xǁTrustRegistryǁtrust_all__mutmut_8': xǁTrustRegistryǁtrust_all__mutmut_8, 
        'xǁTrustRegistryǁtrust_all__mutmut_9': xǁTrustRegistryǁtrust_all__mutmut_9, 
        'xǁTrustRegistryǁtrust_all__mutmut_10': xǁTrustRegistryǁtrust_all__mutmut_10, 
        'xǁTrustRegistryǁtrust_all__mutmut_11': xǁTrustRegistryǁtrust_all__mutmut_11, 
        'xǁTrustRegistryǁtrust_all__mutmut_12': xǁTrustRegistryǁtrust_all__mutmut_12
    }
    
    def trust_all(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁtrust_all__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁtrust_all__mutmut_mutants"), args, kwargs, self)
        return result 
    
    trust_all.__signature__ = _mutmut_signature(xǁTrustRegistryǁtrust_all__mutmut_orig)
    xǁTrustRegistryǁtrust_all__mutmut_orig.__name__ = 'xǁTrustRegistryǁtrust_all'

    def xǁTrustRegistryǁis_at_least_verified__mutmut_orig(self, tool_name: str) -> bool:
        """Return ``True`` if the tool is VERIFIED or TRUSTED."""
        return self.level(tool_name) in (TrustLevel.VERIFIED, TrustLevel.TRUSTED)

    def xǁTrustRegistryǁis_at_least_verified__mutmut_1(self, tool_name: str) -> bool:
        """Return ``True`` if the tool is VERIFIED or TRUSTED."""
        return self.level(None) in (TrustLevel.VERIFIED, TrustLevel.TRUSTED)

    def xǁTrustRegistryǁis_at_least_verified__mutmut_2(self, tool_name: str) -> bool:
        """Return ``True`` if the tool is VERIFIED or TRUSTED."""
        return self.level(tool_name) not in (TrustLevel.VERIFIED, TrustLevel.TRUSTED)
    
    xǁTrustRegistryǁis_at_least_verified__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁis_at_least_verified__mutmut_1': xǁTrustRegistryǁis_at_least_verified__mutmut_1, 
        'xǁTrustRegistryǁis_at_least_verified__mutmut_2': xǁTrustRegistryǁis_at_least_verified__mutmut_2
    }
    
    def is_at_least_verified(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁis_at_least_verified__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁis_at_least_verified__mutmut_mutants"), args, kwargs, self)
        return result 
    
    is_at_least_verified.__signature__ = _mutmut_signature(xǁTrustRegistryǁis_at_least_verified__mutmut_orig)
    xǁTrustRegistryǁis_at_least_verified__mutmut_orig.__name__ = 'xǁTrustRegistryǁis_at_least_verified'

    def xǁTrustRegistryǁis_trusted__mutmut_orig(self, tool_name: str) -> bool:
        """Return ``True`` if the tool is TRUSTED."""
        return self.level(tool_name) == TrustLevel.TRUSTED

    def xǁTrustRegistryǁis_trusted__mutmut_1(self, tool_name: str) -> bool:
        """Return ``True`` if the tool is TRUSTED."""
        return self.level(None) == TrustLevel.TRUSTED

    def xǁTrustRegistryǁis_trusted__mutmut_2(self, tool_name: str) -> bool:
        """Return ``True`` if the tool is TRUSTED."""
        return self.level(tool_name) != TrustLevel.TRUSTED
    
    xǁTrustRegistryǁis_trusted__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁis_trusted__mutmut_1': xǁTrustRegistryǁis_trusted__mutmut_1, 
        'xǁTrustRegistryǁis_trusted__mutmut_2': xǁTrustRegistryǁis_trusted__mutmut_2
    }
    
    def is_trusted(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁis_trusted__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁis_trusted__mutmut_mutants"), args, kwargs, self)
        return result 
    
    is_trusted.__signature__ = _mutmut_signature(xǁTrustRegistryǁis_trusted__mutmut_orig)
    xǁTrustRegistryǁis_trusted__mutmut_orig.__name__ = 'xǁTrustRegistryǁis_trusted'

    def xǁTrustRegistryǁget_report__mutmut_orig(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_1(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = None
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_2(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "XXuntrustedXX": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_3(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "UNTRUSTED": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_4(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "XXverifiedXX": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_5(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "VERIFIED": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_6(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "XXtrustedXX": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_7(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "TRUSTED": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_8(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(None):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_9(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(None)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_10(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "XXtotal_toolsXX": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_11(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "TOTAL_TOOLS": len(self._levels),
            "by_level": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_12(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "XXby_levelXX": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_13(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "BY_LEVEL": by_level,
            "counts": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_14(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "XXcountsXX": {k: len(v) for k, v in by_level.items()},
        }

    def xǁTrustRegistryǁget_report__mutmut_15(self) -> dict[str, Any]:
        """Return current trust state as a JSON-serializable dict."""
        # Reload before reporting
        self._load()
        by_level: dict[str, list[str]] = {
            "untrusted": [],
            "verified": [],
            "trusted": [],
        }
        for name, lvl in sorted(self._levels.items()):
            by_level[lvl.value].append(name)
        return {
            "total_tools": len(self._levels),
            "by_level": by_level,
            "COUNTS": {k: len(v) for k, v in by_level.items()},
        }
    
    xǁTrustRegistryǁget_report__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁget_report__mutmut_1': xǁTrustRegistryǁget_report__mutmut_1, 
        'xǁTrustRegistryǁget_report__mutmut_2': xǁTrustRegistryǁget_report__mutmut_2, 
        'xǁTrustRegistryǁget_report__mutmut_3': xǁTrustRegistryǁget_report__mutmut_3, 
        'xǁTrustRegistryǁget_report__mutmut_4': xǁTrustRegistryǁget_report__mutmut_4, 
        'xǁTrustRegistryǁget_report__mutmut_5': xǁTrustRegistryǁget_report__mutmut_5, 
        'xǁTrustRegistryǁget_report__mutmut_6': xǁTrustRegistryǁget_report__mutmut_6, 
        'xǁTrustRegistryǁget_report__mutmut_7': xǁTrustRegistryǁget_report__mutmut_7, 
        'xǁTrustRegistryǁget_report__mutmut_8': xǁTrustRegistryǁget_report__mutmut_8, 
        'xǁTrustRegistryǁget_report__mutmut_9': xǁTrustRegistryǁget_report__mutmut_9, 
        'xǁTrustRegistryǁget_report__mutmut_10': xǁTrustRegistryǁget_report__mutmut_10, 
        'xǁTrustRegistryǁget_report__mutmut_11': xǁTrustRegistryǁget_report__mutmut_11, 
        'xǁTrustRegistryǁget_report__mutmut_12': xǁTrustRegistryǁget_report__mutmut_12, 
        'xǁTrustRegistryǁget_report__mutmut_13': xǁTrustRegistryǁget_report__mutmut_13, 
        'xǁTrustRegistryǁget_report__mutmut_14': xǁTrustRegistryǁget_report__mutmut_14, 
        'xǁTrustRegistryǁget_report__mutmut_15': xǁTrustRegistryǁget_report__mutmut_15
    }
    
    def get_report(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁget_report__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁget_report__mutmut_mutants"), args, kwargs, self)
        return result 
    
    get_report.__signature__ = _mutmut_signature(xǁTrustRegistryǁget_report__mutmut_orig)
    xǁTrustRegistryǁget_report__mutmut_orig.__name__ = 'xǁTrustRegistryǁget_report'

    def xǁTrustRegistryǁcall__mutmut_orig(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_1(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = None
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_2(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = None
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_3(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(None)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_4(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is not None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_5(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(None)
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_6(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = None
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_7(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get(None)
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_8(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("XXhandlerXX")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_9(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("HANDLER")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_10(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is not None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_11(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(None)
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_12(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = None
        if isinstance(result, dict):
            return result
        return {"result": result}

    def xǁTrustRegistryǁcall__mutmut_13(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"XXresultXX": result}

    def xǁTrustRegistryǁcall__mutmut_14(self, name: str, **kwargs: Any) -> dict[str, Any]:
        """Execute a tool by name via the tool registry.

        Args:
            name: Fully-qualified tool name.
            **kwargs: Tool arguments.

        Returns:
            Tool result dictionary.

        Raises:
            KeyError: If the tool is not registered.
        """
        registry = get_tool_registry()
        tool = registry.get(name)
        if tool is None:
            raise KeyError(f"Unknown tool: {name!r}")
        handler = tool.get("handler")
        if handler is None:
            raise KeyError(f"Tool {name!r} has no handler")
        result = handler(**kwargs)
        if isinstance(result, dict):
            return result
        return {"RESULT": result}
    
    xǁTrustRegistryǁcall__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁcall__mutmut_1': xǁTrustRegistryǁcall__mutmut_1, 
        'xǁTrustRegistryǁcall__mutmut_2': xǁTrustRegistryǁcall__mutmut_2, 
        'xǁTrustRegistryǁcall__mutmut_3': xǁTrustRegistryǁcall__mutmut_3, 
        'xǁTrustRegistryǁcall__mutmut_4': xǁTrustRegistryǁcall__mutmut_4, 
        'xǁTrustRegistryǁcall__mutmut_5': xǁTrustRegistryǁcall__mutmut_5, 
        'xǁTrustRegistryǁcall__mutmut_6': xǁTrustRegistryǁcall__mutmut_6, 
        'xǁTrustRegistryǁcall__mutmut_7': xǁTrustRegistryǁcall__mutmut_7, 
        'xǁTrustRegistryǁcall__mutmut_8': xǁTrustRegistryǁcall__mutmut_8, 
        'xǁTrustRegistryǁcall__mutmut_9': xǁTrustRegistryǁcall__mutmut_9, 
        'xǁTrustRegistryǁcall__mutmut_10': xǁTrustRegistryǁcall__mutmut_10, 
        'xǁTrustRegistryǁcall__mutmut_11': xǁTrustRegistryǁcall__mutmut_11, 
        'xǁTrustRegistryǁcall__mutmut_12': xǁTrustRegistryǁcall__mutmut_12, 
        'xǁTrustRegistryǁcall__mutmut_13': xǁTrustRegistryǁcall__mutmut_13, 
        'xǁTrustRegistryǁcall__mutmut_14': xǁTrustRegistryǁcall__mutmut_14
    }
    
    def call(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁcall__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁcall__mutmut_mutants"), args, kwargs, self)
        return result 
    
    call.__signature__ = _mutmut_signature(xǁTrustRegistryǁcall__mutmut_orig)
    xǁTrustRegistryǁcall__mutmut_orig.__name__ = 'xǁTrustRegistryǁcall'

    def xǁTrustRegistryǁreset__mutmut_orig(self) -> None:
        """Reset all tools to UNTRUSTED."""
        for name in self._levels:
            self._levels[name] = TrustLevel.UNTRUSTED
        self._save()

    def xǁTrustRegistryǁreset__mutmut_1(self) -> None:
        """Reset all tools to UNTRUSTED."""
        for name in self._levels:
            self._levels[name] = None
        self._save()
    
    xǁTrustRegistryǁreset__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTrustRegistryǁreset__mutmut_1': xǁTrustRegistryǁreset__mutmut_1
    }
    
    def reset(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTrustRegistryǁreset__mutmut_orig"), object.__getattribute__(self, "xǁTrustRegistryǁreset__mutmut_mutants"), args, kwargs, self)
        return result 
    
    reset.__signature__ = _mutmut_signature(xǁTrustRegistryǁreset__mutmut_orig)
    xǁTrustRegistryǁreset__mutmut_orig.__name__ = 'xǁTrustRegistryǁreset'


# ── Module-level singleton ────────────────────────────────────────────

_registry = TrustRegistry()


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_orig() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_1() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = None

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_2() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = None

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_3() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = None
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_4() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = None
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_5() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(None)
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_6() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = None
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_7() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = None
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_8() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = None

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_9() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "XXsafeXX": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_10() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "SAFE": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_11() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "XXdestructiveXX": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_12() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "DESTRUCTIVE": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_13() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "XXtotalXX": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_14() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "TOTAL": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_15() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = None
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_16() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = None
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_17() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = +1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_18() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -2.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_19() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = None
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_20() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 1.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_21() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = None
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_22() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = None
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_23() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"XXnameXX": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_24() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"NAME": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_25() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "XXerrorXX": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_26() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "ERROR": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_27() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "XXImport failedXX"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_28() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_29() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "IMPORT FAILED"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_30() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = None
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_31() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) + discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_32() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(None) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_33() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else +1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_34() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -2.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_35() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = None
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_36() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = None
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_37() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = None # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_38() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "XXstdio/httpXX" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_39() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "STDIO/HTTP" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_40() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = None
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_41() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = None
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_42() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = None
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_43() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = None
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_44() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "XXunknownXX"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_45() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "UNKNOWN"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_46() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = None
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_47() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "XXunknownXX"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_48() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "UNKNOWN"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_49() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = None
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_50() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 1
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_51() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = None

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_52() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 1

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_53() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = None

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_54() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "XXstatusXX": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_55() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "STATUS": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_56() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "XXverifiedXX", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_57() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "VERIFIED", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_58() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "XXtoolsXX": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_59() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "TOOLS": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_60() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "XXsafeXX": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_61() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "SAFE": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_62() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(None),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_63() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(None)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_64() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "XXdestructiveXX": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_65() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "DESTRUCTIVE": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_66() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(None),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_67() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(None)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_68() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "XXtotalXX": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_69() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "TOTAL": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_70() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "XXby_categoryXX": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_71() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "BY_CATEGORY": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_72() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "XXmodulesXX": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_73() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "MODULES": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_74() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "XXloadedXX": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_75() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "LOADED": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_76() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "XXfailedXX": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_77() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "FAILED": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_78() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "XXtotalXX": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_79() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "TOTAL": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_80() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) - len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_81() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "XXtrustXX": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_82() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "TRUST": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_83() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "XXpromoted_to_verifiedXX": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_84() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "PROMOTED_TO_VERIFIED": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_85() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "XXlevelXX": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_86() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "LEVEL": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_87() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "XXmixedXX", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_88() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "MIXED", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_89() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "XXaudit_entriesXX": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_90() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "AUDIT_ENTRIES": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_91() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 1, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_92() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "XXgateway_healthyXX": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_93() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "GATEWAY_HEALTHY": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_94() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": False,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_95() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "XXreportXX": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_96() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "REPORT": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_97() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "XXmcpXX": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_98() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "MCP": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_99() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "XXserver_nameXX": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_100() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "SERVER_NAME": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_101() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "XXtransportXX": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_102() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "TRANSPORT": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_103() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "XXresourcesXX": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_104() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "RESOURCES": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_105() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "XXpromptsXX": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_106() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "PROMPTS": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_107() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "XXdiscoveryXX": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_108() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "DISCOVERY": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_109() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "XXcache_age_secondsXX": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_110() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "CACHE_AGE_SECONDS": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_111() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "XXlast_scan_duration_msXX": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_112() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "LAST_SCAN_DURATION_MS": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_113() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        None,
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_114() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        None,
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_115() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        None,
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_116() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        None,
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_117() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_118() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_119() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_120() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_121() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "XXVerify capabilities: %d tools (%d safe), %d modules loaded.XX",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_122() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_123() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "VERIFY CAPABILITIES: %D TOOLS (%D SAFE), %D MODULES LOADED.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_124() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["XXtoolsXX"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_125() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["TOOLS"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_126() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["XXtotalXX"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_127() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["TOTAL"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_128() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["XXtoolsXX"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_129() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["TOOLS"]["by_category"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_130() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["XXby_categoryXX"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_131() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["BY_CATEGORY"]["safe"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_132() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["XXsafeXX"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_133() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["SAFE"],
        report["modules"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_134() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["XXmodulesXX"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_135() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["MODULES"]["loaded"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_136() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["XXloadedXX"],
    )
    return report


# =====================================================================
# Public API
# =====================================================================

def x_verify_capabilities__mutmut_137() -> dict[str, Any]:
    """Run a full read-only audit of all Codomyrmex capabilities.

    This is the backing function for ``/codomyrmexVerify``.

    Returns:
        Structured report with modules, tools, resources, prompts,
        MCP server health, PAI bridge status, and trust state.
    """
    # ── Module inventory ──────────────────────────────────────────
    import codomyrmex
    modules = codomyrmex.list_modules()

    # ── Promote safe tools to VERIFIED (before snapshot) ──────────
    promoted = _registry.verify_all_safe()

    # ── Tool registry ─────────────────────────────────────────────
    # Ensures detailed tool stats, including versions and availability
    # Refresh discovery first just in case
    _discover_dynamic_tools()
    
    registry = get_tool_registry()
    tool_names = sorted(registry.list_tools())
    
    # Calculate tool categorization stats
    safe_tools = _get_safe_tools()
    destructive_tools = _get_destructive_tools()
    by_category = {
        "safe": len(safe_tools),
        "destructive": len(destructive_tools),
        "total": len(tool_names),
    }

    # ── Module Stats ──────────────────────────────────────────────
    # We check discovery metrics for failed modules
    from codomyrmex.model_context_protocol.discovery import MCPDiscovery
    # We need to access the singleton-ish discovery metrics from mcp_bridge's discovery engine
    # but mcp_bridge hides the engine instance. 
    # Actually create_codomyrmex_mcp_server._discovery_metrics_provider() gives us metrics.
    # Or better, we expose a getter in mcp_bridge.
    # For now, we reuse the pattern from mcp_bridge or just re-read the attribute if we can.
    # Actually, mcp_bridge._DISCOVERY_ENGINE is private but we can access it for now or rely on
    # invalidate_tool_cache().
    
    # Let's use the provider if available or a direct access pattern
    failed_modules = []
    discovery_cache_age = -1.0
    discovery_last_duration = 0.0
    try:
        from codomyrmex.agents.pai.mcp_bridge import _DISCOVERY_ENGINE
        discovery_metrics = _DISCOVERY_ENGINE.get_metrics()
        failed_modules = [
            {"name": m, "error": "Import failed"} # Metric only stores name
            for m in discovery_metrics.failed_modules
        ]
        discovery_cache_age = (
            (datetime.now(timezone.utc) - discovery_metrics.last_scan_time).total_seconds() 
            if discovery_metrics.last_scan_time else -1.0
        )
        discovery_last_duration = discovery_metrics.scan_duration_ms
    except ImportError:
        pass # _DISCOVERY_ENGINE might not be directly importable or available in all setups
    except AttributeError:
        pass # _DISCOVERY_ENGINE might not have get_metrics() or related attributes

    # ── MCP server health ─────────────────────────────────────────
    try:
        # We don't want to create a full server every time if we can avoid it,
        # but it's the robust check.
        server = create_codomyrmex_mcp_server()
        mcp_transport = "stdio/http" # Configurable, but default
        mcp_resources = len(server._resources)
        mcp_prompts = len(server._prompts)
        mcp_server_name = server.config.name
    except Exception:
        mcp_server_name = "unknown"
        mcp_transport = "unknown"
        mcp_resources = 0
        mcp_prompts = 0

    # ── Validation ────────────────────────────────────────────────
    
    report = {
        "status": "verified", # Keep for backwards compatibility, though less meaningful now
        "tools": {
            "safe": sorted(list(safe_tools)),
            "destructive": sorted(list(destructive_tools)),
            "total": len(tool_names),
            "by_category": by_category,
        },
        "modules": {
            "loaded": len(modules),
            "failed": failed_modules,
            "total": len(modules) + len(failed_modules),
        },
        "trust": {
            "promoted_to_verified": promoted, # Keep for backwards compatibility
            "level": "mixed", # Aggregate level not really meaningful defined here yet
            "audit_entries": 0, # TODO(stream-2): Implement audit entry counting
            "gateway_healthy": True,
            "report": _registry.get_report(),
        },
        "mcp": {
            "server_name": mcp_server_name,
            "transport": mcp_transport,
            "resources": mcp_resources,
            "prompts": mcp_prompts,
        },
        "discovery": {
            "cache_age_seconds": discovery_cache_age,
            "last_scan_duration_ms": discovery_last_duration,
        }
    }

    logger.info(
        "Verify capabilities: %d tools (%d safe), %d modules loaded.",
        report["tools"]["total"],
        report["tools"]["by_category"]["safe"],
        report["modules"]["LOADED"],
    )
    return report

x_verify_capabilities__mutmut_mutants : ClassVar[MutantDict] = {
'x_verify_capabilities__mutmut_1': x_verify_capabilities__mutmut_1, 
    'x_verify_capabilities__mutmut_2': x_verify_capabilities__mutmut_2, 
    'x_verify_capabilities__mutmut_3': x_verify_capabilities__mutmut_3, 
    'x_verify_capabilities__mutmut_4': x_verify_capabilities__mutmut_4, 
    'x_verify_capabilities__mutmut_5': x_verify_capabilities__mutmut_5, 
    'x_verify_capabilities__mutmut_6': x_verify_capabilities__mutmut_6, 
    'x_verify_capabilities__mutmut_7': x_verify_capabilities__mutmut_7, 
    'x_verify_capabilities__mutmut_8': x_verify_capabilities__mutmut_8, 
    'x_verify_capabilities__mutmut_9': x_verify_capabilities__mutmut_9, 
    'x_verify_capabilities__mutmut_10': x_verify_capabilities__mutmut_10, 
    'x_verify_capabilities__mutmut_11': x_verify_capabilities__mutmut_11, 
    'x_verify_capabilities__mutmut_12': x_verify_capabilities__mutmut_12, 
    'x_verify_capabilities__mutmut_13': x_verify_capabilities__mutmut_13, 
    'x_verify_capabilities__mutmut_14': x_verify_capabilities__mutmut_14, 
    'x_verify_capabilities__mutmut_15': x_verify_capabilities__mutmut_15, 
    'x_verify_capabilities__mutmut_16': x_verify_capabilities__mutmut_16, 
    'x_verify_capabilities__mutmut_17': x_verify_capabilities__mutmut_17, 
    'x_verify_capabilities__mutmut_18': x_verify_capabilities__mutmut_18, 
    'x_verify_capabilities__mutmut_19': x_verify_capabilities__mutmut_19, 
    'x_verify_capabilities__mutmut_20': x_verify_capabilities__mutmut_20, 
    'x_verify_capabilities__mutmut_21': x_verify_capabilities__mutmut_21, 
    'x_verify_capabilities__mutmut_22': x_verify_capabilities__mutmut_22, 
    'x_verify_capabilities__mutmut_23': x_verify_capabilities__mutmut_23, 
    'x_verify_capabilities__mutmut_24': x_verify_capabilities__mutmut_24, 
    'x_verify_capabilities__mutmut_25': x_verify_capabilities__mutmut_25, 
    'x_verify_capabilities__mutmut_26': x_verify_capabilities__mutmut_26, 
    'x_verify_capabilities__mutmut_27': x_verify_capabilities__mutmut_27, 
    'x_verify_capabilities__mutmut_28': x_verify_capabilities__mutmut_28, 
    'x_verify_capabilities__mutmut_29': x_verify_capabilities__mutmut_29, 
    'x_verify_capabilities__mutmut_30': x_verify_capabilities__mutmut_30, 
    'x_verify_capabilities__mutmut_31': x_verify_capabilities__mutmut_31, 
    'x_verify_capabilities__mutmut_32': x_verify_capabilities__mutmut_32, 
    'x_verify_capabilities__mutmut_33': x_verify_capabilities__mutmut_33, 
    'x_verify_capabilities__mutmut_34': x_verify_capabilities__mutmut_34, 
    'x_verify_capabilities__mutmut_35': x_verify_capabilities__mutmut_35, 
    'x_verify_capabilities__mutmut_36': x_verify_capabilities__mutmut_36, 
    'x_verify_capabilities__mutmut_37': x_verify_capabilities__mutmut_37, 
    'x_verify_capabilities__mutmut_38': x_verify_capabilities__mutmut_38, 
    'x_verify_capabilities__mutmut_39': x_verify_capabilities__mutmut_39, 
    'x_verify_capabilities__mutmut_40': x_verify_capabilities__mutmut_40, 
    'x_verify_capabilities__mutmut_41': x_verify_capabilities__mutmut_41, 
    'x_verify_capabilities__mutmut_42': x_verify_capabilities__mutmut_42, 
    'x_verify_capabilities__mutmut_43': x_verify_capabilities__mutmut_43, 
    'x_verify_capabilities__mutmut_44': x_verify_capabilities__mutmut_44, 
    'x_verify_capabilities__mutmut_45': x_verify_capabilities__mutmut_45, 
    'x_verify_capabilities__mutmut_46': x_verify_capabilities__mutmut_46, 
    'x_verify_capabilities__mutmut_47': x_verify_capabilities__mutmut_47, 
    'x_verify_capabilities__mutmut_48': x_verify_capabilities__mutmut_48, 
    'x_verify_capabilities__mutmut_49': x_verify_capabilities__mutmut_49, 
    'x_verify_capabilities__mutmut_50': x_verify_capabilities__mutmut_50, 
    'x_verify_capabilities__mutmut_51': x_verify_capabilities__mutmut_51, 
    'x_verify_capabilities__mutmut_52': x_verify_capabilities__mutmut_52, 
    'x_verify_capabilities__mutmut_53': x_verify_capabilities__mutmut_53, 
    'x_verify_capabilities__mutmut_54': x_verify_capabilities__mutmut_54, 
    'x_verify_capabilities__mutmut_55': x_verify_capabilities__mutmut_55, 
    'x_verify_capabilities__mutmut_56': x_verify_capabilities__mutmut_56, 
    'x_verify_capabilities__mutmut_57': x_verify_capabilities__mutmut_57, 
    'x_verify_capabilities__mutmut_58': x_verify_capabilities__mutmut_58, 
    'x_verify_capabilities__mutmut_59': x_verify_capabilities__mutmut_59, 
    'x_verify_capabilities__mutmut_60': x_verify_capabilities__mutmut_60, 
    'x_verify_capabilities__mutmut_61': x_verify_capabilities__mutmut_61, 
    'x_verify_capabilities__mutmut_62': x_verify_capabilities__mutmut_62, 
    'x_verify_capabilities__mutmut_63': x_verify_capabilities__mutmut_63, 
    'x_verify_capabilities__mutmut_64': x_verify_capabilities__mutmut_64, 
    'x_verify_capabilities__mutmut_65': x_verify_capabilities__mutmut_65, 
    'x_verify_capabilities__mutmut_66': x_verify_capabilities__mutmut_66, 
    'x_verify_capabilities__mutmut_67': x_verify_capabilities__mutmut_67, 
    'x_verify_capabilities__mutmut_68': x_verify_capabilities__mutmut_68, 
    'x_verify_capabilities__mutmut_69': x_verify_capabilities__mutmut_69, 
    'x_verify_capabilities__mutmut_70': x_verify_capabilities__mutmut_70, 
    'x_verify_capabilities__mutmut_71': x_verify_capabilities__mutmut_71, 
    'x_verify_capabilities__mutmut_72': x_verify_capabilities__mutmut_72, 
    'x_verify_capabilities__mutmut_73': x_verify_capabilities__mutmut_73, 
    'x_verify_capabilities__mutmut_74': x_verify_capabilities__mutmut_74, 
    'x_verify_capabilities__mutmut_75': x_verify_capabilities__mutmut_75, 
    'x_verify_capabilities__mutmut_76': x_verify_capabilities__mutmut_76, 
    'x_verify_capabilities__mutmut_77': x_verify_capabilities__mutmut_77, 
    'x_verify_capabilities__mutmut_78': x_verify_capabilities__mutmut_78, 
    'x_verify_capabilities__mutmut_79': x_verify_capabilities__mutmut_79, 
    'x_verify_capabilities__mutmut_80': x_verify_capabilities__mutmut_80, 
    'x_verify_capabilities__mutmut_81': x_verify_capabilities__mutmut_81, 
    'x_verify_capabilities__mutmut_82': x_verify_capabilities__mutmut_82, 
    'x_verify_capabilities__mutmut_83': x_verify_capabilities__mutmut_83, 
    'x_verify_capabilities__mutmut_84': x_verify_capabilities__mutmut_84, 
    'x_verify_capabilities__mutmut_85': x_verify_capabilities__mutmut_85, 
    'x_verify_capabilities__mutmut_86': x_verify_capabilities__mutmut_86, 
    'x_verify_capabilities__mutmut_87': x_verify_capabilities__mutmut_87, 
    'x_verify_capabilities__mutmut_88': x_verify_capabilities__mutmut_88, 
    'x_verify_capabilities__mutmut_89': x_verify_capabilities__mutmut_89, 
    'x_verify_capabilities__mutmut_90': x_verify_capabilities__mutmut_90, 
    'x_verify_capabilities__mutmut_91': x_verify_capabilities__mutmut_91, 
    'x_verify_capabilities__mutmut_92': x_verify_capabilities__mutmut_92, 
    'x_verify_capabilities__mutmut_93': x_verify_capabilities__mutmut_93, 
    'x_verify_capabilities__mutmut_94': x_verify_capabilities__mutmut_94, 
    'x_verify_capabilities__mutmut_95': x_verify_capabilities__mutmut_95, 
    'x_verify_capabilities__mutmut_96': x_verify_capabilities__mutmut_96, 
    'x_verify_capabilities__mutmut_97': x_verify_capabilities__mutmut_97, 
    'x_verify_capabilities__mutmut_98': x_verify_capabilities__mutmut_98, 
    'x_verify_capabilities__mutmut_99': x_verify_capabilities__mutmut_99, 
    'x_verify_capabilities__mutmut_100': x_verify_capabilities__mutmut_100, 
    'x_verify_capabilities__mutmut_101': x_verify_capabilities__mutmut_101, 
    'x_verify_capabilities__mutmut_102': x_verify_capabilities__mutmut_102, 
    'x_verify_capabilities__mutmut_103': x_verify_capabilities__mutmut_103, 
    'x_verify_capabilities__mutmut_104': x_verify_capabilities__mutmut_104, 
    'x_verify_capabilities__mutmut_105': x_verify_capabilities__mutmut_105, 
    'x_verify_capabilities__mutmut_106': x_verify_capabilities__mutmut_106, 
    'x_verify_capabilities__mutmut_107': x_verify_capabilities__mutmut_107, 
    'x_verify_capabilities__mutmut_108': x_verify_capabilities__mutmut_108, 
    'x_verify_capabilities__mutmut_109': x_verify_capabilities__mutmut_109, 
    'x_verify_capabilities__mutmut_110': x_verify_capabilities__mutmut_110, 
    'x_verify_capabilities__mutmut_111': x_verify_capabilities__mutmut_111, 
    'x_verify_capabilities__mutmut_112': x_verify_capabilities__mutmut_112, 
    'x_verify_capabilities__mutmut_113': x_verify_capabilities__mutmut_113, 
    'x_verify_capabilities__mutmut_114': x_verify_capabilities__mutmut_114, 
    'x_verify_capabilities__mutmut_115': x_verify_capabilities__mutmut_115, 
    'x_verify_capabilities__mutmut_116': x_verify_capabilities__mutmut_116, 
    'x_verify_capabilities__mutmut_117': x_verify_capabilities__mutmut_117, 
    'x_verify_capabilities__mutmut_118': x_verify_capabilities__mutmut_118, 
    'x_verify_capabilities__mutmut_119': x_verify_capabilities__mutmut_119, 
    'x_verify_capabilities__mutmut_120': x_verify_capabilities__mutmut_120, 
    'x_verify_capabilities__mutmut_121': x_verify_capabilities__mutmut_121, 
    'x_verify_capabilities__mutmut_122': x_verify_capabilities__mutmut_122, 
    'x_verify_capabilities__mutmut_123': x_verify_capabilities__mutmut_123, 
    'x_verify_capabilities__mutmut_124': x_verify_capabilities__mutmut_124, 
    'x_verify_capabilities__mutmut_125': x_verify_capabilities__mutmut_125, 
    'x_verify_capabilities__mutmut_126': x_verify_capabilities__mutmut_126, 
    'x_verify_capabilities__mutmut_127': x_verify_capabilities__mutmut_127, 
    'x_verify_capabilities__mutmut_128': x_verify_capabilities__mutmut_128, 
    'x_verify_capabilities__mutmut_129': x_verify_capabilities__mutmut_129, 
    'x_verify_capabilities__mutmut_130': x_verify_capabilities__mutmut_130, 
    'x_verify_capabilities__mutmut_131': x_verify_capabilities__mutmut_131, 
    'x_verify_capabilities__mutmut_132': x_verify_capabilities__mutmut_132, 
    'x_verify_capabilities__mutmut_133': x_verify_capabilities__mutmut_133, 
    'x_verify_capabilities__mutmut_134': x_verify_capabilities__mutmut_134, 
    'x_verify_capabilities__mutmut_135': x_verify_capabilities__mutmut_135, 
    'x_verify_capabilities__mutmut_136': x_verify_capabilities__mutmut_136, 
    'x_verify_capabilities__mutmut_137': x_verify_capabilities__mutmut_137
}

def verify_capabilities(*args, **kwargs):
    result = _mutmut_trampoline(x_verify_capabilities__mutmut_orig, x_verify_capabilities__mutmut_mutants, args, kwargs)
    return result 

verify_capabilities.__signature__ = _mutmut_signature(x_verify_capabilities__mutmut_orig)
x_verify_capabilities__mutmut_orig.__name__ = 'x_verify_capabilities'


def x_trust_tool__mutmut_orig(tool_name: str) -> dict[str, Any]:
    """Promote a single tool to TRUSTED.

    This is the backing function for ``/codomyrmexTrust <tool>``.

    Args:
        tool_name: Fully-qualified tool name (e.g. ``"codomyrmex.write_file"``).

    Returns:
        Trust state after promotion.
    """
    # Note: We don't trigger global trust change for single tool, 
    # but we could if we tracked per-tool granularity in events.
    new_level = _registry.trust_tool(tool_name)
    return {
        "tool": tool_name,
        "new_level": new_level.value,
        "report": _registry.get_report(),
    }


def x_trust_tool__mutmut_1(tool_name: str) -> dict[str, Any]:
    """Promote a single tool to TRUSTED.

    This is the backing function for ``/codomyrmexTrust <tool>``.

    Args:
        tool_name: Fully-qualified tool name (e.g. ``"codomyrmex.write_file"``).

    Returns:
        Trust state after promotion.
    """
    # Note: We don't trigger global trust change for single tool, 
    # but we could if we tracked per-tool granularity in events.
    new_level = None
    return {
        "tool": tool_name,
        "new_level": new_level.value,
        "report": _registry.get_report(),
    }


def x_trust_tool__mutmut_2(tool_name: str) -> dict[str, Any]:
    """Promote a single tool to TRUSTED.

    This is the backing function for ``/codomyrmexTrust <tool>``.

    Args:
        tool_name: Fully-qualified tool name (e.g. ``"codomyrmex.write_file"``).

    Returns:
        Trust state after promotion.
    """
    # Note: We don't trigger global trust change for single tool, 
    # but we could if we tracked per-tool granularity in events.
    new_level = _registry.trust_tool(None)
    return {
        "tool": tool_name,
        "new_level": new_level.value,
        "report": _registry.get_report(),
    }


def x_trust_tool__mutmut_3(tool_name: str) -> dict[str, Any]:
    """Promote a single tool to TRUSTED.

    This is the backing function for ``/codomyrmexTrust <tool>``.

    Args:
        tool_name: Fully-qualified tool name (e.g. ``"codomyrmex.write_file"``).

    Returns:
        Trust state after promotion.
    """
    # Note: We don't trigger global trust change for single tool, 
    # but we could if we tracked per-tool granularity in events.
    new_level = _registry.trust_tool(tool_name)
    return {
        "XXtoolXX": tool_name,
        "new_level": new_level.value,
        "report": _registry.get_report(),
    }


def x_trust_tool__mutmut_4(tool_name: str) -> dict[str, Any]:
    """Promote a single tool to TRUSTED.

    This is the backing function for ``/codomyrmexTrust <tool>``.

    Args:
        tool_name: Fully-qualified tool name (e.g. ``"codomyrmex.write_file"``).

    Returns:
        Trust state after promotion.
    """
    # Note: We don't trigger global trust change for single tool, 
    # but we could if we tracked per-tool granularity in events.
    new_level = _registry.trust_tool(tool_name)
    return {
        "TOOL": tool_name,
        "new_level": new_level.value,
        "report": _registry.get_report(),
    }


def x_trust_tool__mutmut_5(tool_name: str) -> dict[str, Any]:
    """Promote a single tool to TRUSTED.

    This is the backing function for ``/codomyrmexTrust <tool>``.

    Args:
        tool_name: Fully-qualified tool name (e.g. ``"codomyrmex.write_file"``).

    Returns:
        Trust state after promotion.
    """
    # Note: We don't trigger global trust change for single tool, 
    # but we could if we tracked per-tool granularity in events.
    new_level = _registry.trust_tool(tool_name)
    return {
        "tool": tool_name,
        "XXnew_levelXX": new_level.value,
        "report": _registry.get_report(),
    }


def x_trust_tool__mutmut_6(tool_name: str) -> dict[str, Any]:
    """Promote a single tool to TRUSTED.

    This is the backing function for ``/codomyrmexTrust <tool>``.

    Args:
        tool_name: Fully-qualified tool name (e.g. ``"codomyrmex.write_file"``).

    Returns:
        Trust state after promotion.
    """
    # Note: We don't trigger global trust change for single tool, 
    # but we could if we tracked per-tool granularity in events.
    new_level = _registry.trust_tool(tool_name)
    return {
        "tool": tool_name,
        "NEW_LEVEL": new_level.value,
        "report": _registry.get_report(),
    }


def x_trust_tool__mutmut_7(tool_name: str) -> dict[str, Any]:
    """Promote a single tool to TRUSTED.

    This is the backing function for ``/codomyrmexTrust <tool>``.

    Args:
        tool_name: Fully-qualified tool name (e.g. ``"codomyrmex.write_file"``).

    Returns:
        Trust state after promotion.
    """
    # Note: We don't trigger global trust change for single tool, 
    # but we could if we tracked per-tool granularity in events.
    new_level = _registry.trust_tool(tool_name)
    return {
        "tool": tool_name,
        "new_level": new_level.value,
        "XXreportXX": _registry.get_report(),
    }


def x_trust_tool__mutmut_8(tool_name: str) -> dict[str, Any]:
    """Promote a single tool to TRUSTED.

    This is the backing function for ``/codomyrmexTrust <tool>``.

    Args:
        tool_name: Fully-qualified tool name (e.g. ``"codomyrmex.write_file"``).

    Returns:
        Trust state after promotion.
    """
    # Note: We don't trigger global trust change for single tool, 
    # but we could if we tracked per-tool granularity in events.
    new_level = _registry.trust_tool(tool_name)
    return {
        "tool": tool_name,
        "new_level": new_level.value,
        "REPORT": _registry.get_report(),
    }

x_trust_tool__mutmut_mutants : ClassVar[MutantDict] = {
'x_trust_tool__mutmut_1': x_trust_tool__mutmut_1, 
    'x_trust_tool__mutmut_2': x_trust_tool__mutmut_2, 
    'x_trust_tool__mutmut_3': x_trust_tool__mutmut_3, 
    'x_trust_tool__mutmut_4': x_trust_tool__mutmut_4, 
    'x_trust_tool__mutmut_5': x_trust_tool__mutmut_5, 
    'x_trust_tool__mutmut_6': x_trust_tool__mutmut_6, 
    'x_trust_tool__mutmut_7': x_trust_tool__mutmut_7, 
    'x_trust_tool__mutmut_8': x_trust_tool__mutmut_8
}

def trust_tool(*args, **kwargs):
    result = _mutmut_trampoline(x_trust_tool__mutmut_orig, x_trust_tool__mutmut_mutants, args, kwargs)
    return result 

trust_tool.__signature__ = _mutmut_signature(x_trust_tool__mutmut_orig)
x_trust_tool__mutmut_orig.__name__ = 'x_trust_tool'


def x_trust_all__mutmut_orig() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_1() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = None
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_2() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = None
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_3() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = None
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_4() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(None, TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_5() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, None)
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_6() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_7() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, )
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_8() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "XXpromotedXX": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_9() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "PROMOTED": promoted,
        "count": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_10() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "XXcountXX": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_11() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "COUNT": len(promoted),
        "report": _registry.get_report(),
    }


def x_trust_all__mutmut_12() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "XXreportXX": _registry.get_report(),
    }


def x_trust_all__mutmut_13() -> dict[str, Any]:
    """Promote **all** tools to TRUSTED.

    Returns:
        Trust state after promotion.
    """
    promoted = _registry.trust_all()
    
    # Update global level if it wasn't already TRUSTED
    # Note: _registry.trust_all() trusts individual tools, but we also track global level
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.TRUSTED
    _trigger_trust_change(old_level, TrustLevel.TRUSTED)
    
    return {
        "promoted": promoted,
        "count": len(promoted),
        "REPORT": _registry.get_report(),
    }

x_trust_all__mutmut_mutants : ClassVar[MutantDict] = {
'x_trust_all__mutmut_1': x_trust_all__mutmut_1, 
    'x_trust_all__mutmut_2': x_trust_all__mutmut_2, 
    'x_trust_all__mutmut_3': x_trust_all__mutmut_3, 
    'x_trust_all__mutmut_4': x_trust_all__mutmut_4, 
    'x_trust_all__mutmut_5': x_trust_all__mutmut_5, 
    'x_trust_all__mutmut_6': x_trust_all__mutmut_6, 
    'x_trust_all__mutmut_7': x_trust_all__mutmut_7, 
    'x_trust_all__mutmut_8': x_trust_all__mutmut_8, 
    'x_trust_all__mutmut_9': x_trust_all__mutmut_9, 
    'x_trust_all__mutmut_10': x_trust_all__mutmut_10, 
    'x_trust_all__mutmut_11': x_trust_all__mutmut_11, 
    'x_trust_all__mutmut_12': x_trust_all__mutmut_12, 
    'x_trust_all__mutmut_13': x_trust_all__mutmut_13
}

def trust_all(*args, **kwargs):
    result = _mutmut_trampoline(x_trust_all__mutmut_orig, x_trust_all__mutmut_mutants, args, kwargs)
    return result 

trust_all.__signature__ = _mutmut_signature(x_trust_all__mutmut_orig)
x_trust_all__mutmut_orig.__name__ = 'x_trust_all'


def get_trust_report() -> dict[str, Any]:
    """Get the current trust state for all tools."""
    return _registry.get_report()


def x_is_trusted__mutmut_orig(tool_name: str) -> bool:
    """Check if a tool is TRUSTED for execution."""
    return _registry.is_trusted(tool_name)


def x_is_trusted__mutmut_1(tool_name: str) -> bool:
    """Check if a tool is TRUSTED for execution."""
    return _registry.is_trusted(None)

x_is_trusted__mutmut_mutants : ClassVar[MutantDict] = {
'x_is_trusted__mutmut_1': x_is_trusted__mutmut_1
}

def is_trusted(*args, **kwargs):
    result = _mutmut_trampoline(x_is_trusted__mutmut_orig, x_is_trusted__mutmut_mutants, args, kwargs)
    return result 

is_trusted.__signature__ = _mutmut_signature(x_is_trusted__mutmut_orig)
x_is_trusted__mutmut_orig.__name__ = 'x_is_trusted'


def x_trusted_call_tool__mutmut_orig(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_1(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = None
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_2(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = None
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_3(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(None)
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_4(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_5(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            None
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_6(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(None)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_7(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = None
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_8(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(None)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_9(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry or "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_10(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "XXschemaXX" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_11(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "SCHEMA" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_12(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" not in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_13(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = None
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_14(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            None, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_15(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            None, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_16(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            None
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_17(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_18(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_19(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_20(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["XXschemaXX"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_21(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["SCHEMA"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_22(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_23(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(None)

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_24(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = None
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_25(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(None)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_26(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(None):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_27(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_28(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(None):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_29(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(None, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_30(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, None, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_31(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, None, current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_32(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", None, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_33(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, None)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_34(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_35(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_36(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_37(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_38(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, )
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_39(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "XXblockedXX", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_40(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "BLOCKED", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_41(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 1.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_42(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                None
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_43(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "XXUse trust_tool() or trust_all() to approve.XX"
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_44(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_45(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "USE TRUST_TOOL() OR TRUST_ALL() TO APPROVE."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_46(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_47(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(None):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_48(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(None, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_49(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, None, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_50(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, None, current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_51(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", None, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_52(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, None)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_53(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_54(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_55(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_56(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_57(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, )
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_58(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "XXblockedXX", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_59(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "BLOCKED", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_60(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 1.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_61(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                None
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_62(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "XXUse trust_tool() or trust_all() to approve.XX"
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_63(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_64(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "USE TRUST_TOOL() OR TRUST_ALL() TO APPROVE."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_65(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION or name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_66(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name not in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_67(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = None
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_68(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop(None, None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_69(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop(None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_70(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", )
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_71(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("XXconfirmation_tokenXX", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_72(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("CONFIRMATION_TOKEN", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_73(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_74(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(None, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_75(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, None, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_76(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, None, _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_77(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", None, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_78(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, None, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_79(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=None)
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_80(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_81(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_82(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_83(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_84(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_85(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               )
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_86(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "XXblockedXX", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_87(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "BLOCKED", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_88(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(None).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_89(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 1.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_90(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError(None))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_91(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("XXInvalid or expired confirmation tokenXX"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_92(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_93(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("INVALID OR EXPIRED CONFIRMATION TOKEN"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_94(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError(None)
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_95(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("XXInvalid or expired confirmation tokenXX")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_96(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_97(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("INVALID OR EXPIRED CONFIRMATION TOKEN")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_98(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = None
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_99(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["XXtool_nameXX"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_100(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["TOOL_NAME"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_101(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] == name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_102(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(None, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_103(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, None, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_104(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, None, _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_105(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", None, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_106(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, None, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_107(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=None)
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_108(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_109(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_110(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_111(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_112(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_113(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               )
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_114(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "XXblockedXX", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_115(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "BLOCKED", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_116(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(None).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_117(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 1.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_118(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError(None))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_119(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("XXToken mismatchXX"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_120(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_121(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("TOKEN MISMATCH"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_122(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError(None)
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_123(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("XXConfirmation token does not match toolXX")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_124(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_125(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("CONFIRMATION TOKEN DOES NOT MATCH TOOL")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_126(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = None
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_127(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(None)
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_128(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = None
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_129(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "XXtimestampXX": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_130(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "TIMESTAMP": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_131(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "XXtool_nameXX": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_132(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "TOOL_NAME": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_133(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "XXargsXX": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_134(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "ARGS": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_135(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(None, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_136(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, None, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_137(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, None, _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_138(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", None, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_139(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, None)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_140(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_141(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_142(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_143(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_144(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, )
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_145(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "XXpending_confirmationXX", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_146(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "PENDING_CONFIRMATION", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_147(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(None).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_148(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 1.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_149(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "XXconfirmation_requiredXX": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_150(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "CONFIRMATION_REQUIRED": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_151(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": False,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_152(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "XXtool_nameXX": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_153(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "TOOL_NAME": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_154(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "XXargs_previewXX": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_155(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "ARGS_PREVIEW": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_156(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "XXconfirm_tokenXX": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_157(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "CONFIRM_TOKEN": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_158(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "XXmessageXX": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_159(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "MESSAGE": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_160(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = None
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_161(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = None
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_162(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "XXsuccessXX"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_163(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "SUCCESS"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_164(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = ""

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_165(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = None
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_166(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(None, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_167(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(**kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_168(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, )
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_169(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = None
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_170(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "XXerrorXX"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_171(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "ERROR"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_172(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = None
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_173(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = None
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_174(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) / 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_175(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() + t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_176(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1001
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_177(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            None,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_178(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            None,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_179(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            None,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_180(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            None,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_181(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            None,
            error_obj
        )


def x_trusted_call_tool__mutmut_182(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            None
        )


def x_trusted_call_tool__mutmut_183(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_184(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            status,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_185(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            _registry.level(name).name,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_186(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            duration,
            error_obj
        )


def x_trusted_call_tool__mutmut_187(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            error_obj
        )


def x_trusted_call_tool__mutmut_188(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(name).name,
            duration,
            )


def x_trusted_call_tool__mutmut_189(name: str, **kwargs: Any) -> dict[str, Any]:
    """Call a Codomyrmex MCP tool with trust enforcement.

    Safe tools require at least VERIFIED.  Destructive tools require TRUSTED.
    Validates arguments against schema **before** checking trust or executing.

    Args:
        name: Tool name (e.g. ``"codomyrmex.list_modules"``).
        **kwargs: Tool arguments.

    Returns:
        Tool result dictionary.

    Raises:
        PermissionError: If the tool's trust level is insufficient.
        KeyError: If the tool is unknown.
        jsonschema.ValidationError: If arguments match schema.
    """
    # Validate tool exists first (raises KeyError for unknown tools).
    registry = get_tool_registry()
    known_tools = set(registry.list_tools())
    if name not in known_tools:
        raise KeyError(
            f"Unknown tool: {name!r}. "
            f"Available: {sorted(known_tools)}"
        )
        
    # Validation Step (Secure by default)
    # We must validate before we even check trust, to catch malformed attacks early.
    tool_entry = registry.get(name)
    if tool_entry and "schema" in tool_entry:
        val_result = validate_tool_arguments(
            name, 
            kwargs, 
            tool_entry["schema"]
        )
        if not val_result.valid:
            raise ValueError(f"Tool argument validation failed: {val_result.errors}")

    # Trust check: safe tools need VERIFIED, destructive tools need TRUSTED
    current_level = _registry.level(name)
    if _is_destructive(name):
        if not _registry.is_trusted(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )
    else:
        if not _registry.is_at_least_verified(name):
            _log_audit_entry(name, kwargs, "blocked", current_level.name, 0.0)
            raise SecurityError(
                f"Tool '{name}' is not trusted (current level: {current_level.name}). "
                "Use trust_tool() or trust_all() to approve."
            )

    # Destructive Tool Confirmation
    if _REQUIRE_CONFIRMATION and name in DESTRUCTIVE_TOOLS:
        _cleanup_expired_confirmations()
        
        # Check for token
        token = kwargs.pop("confirmation_token", None)
        
        if token:
            # Validate token
            if token not in _pending_confirmations:
                _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Invalid or expired confirmation token"))
                raise SecurityError("Invalid or expired confirmation token")
            
            saved = _pending_confirmations[token]
            if saved["tool_name"] != name:
                 _log_audit_entry(name, kwargs, "blocked", _registry.level(name).name, 0.0, 
                               error=SecurityError("Token mismatch"))
                 raise SecurityError("Confirmation token does not match tool")
                 
            # Token valid, proceed. Remove used token.
            del _pending_confirmations[token]
            
        else:
            # Require confirmation
            import uuid
            new_token = str(uuid.uuid4())
            _pending_confirmations[new_token] = {
                "timestamp": time.monotonic(),
                "tool_name": name,
                "args": kwargs
            }
            
            _log_audit_entry(name, kwargs, "pending_confirmation", _registry.level(name).name, 0.0)
            
            return {
                "confirmation_required": True,
                "tool_name": name,
                "args_preview": kwargs,
                "confirm_token": new_token,
                "message": f"Destructive tool '{name}' requires confirmation. Call again with 'confirmation_token': '{new_token}'."
            }

    t0 = time.monotonic()
    status = "success"
    error_obj: Exception | None = None

    try:
        # 3. Execute
        result = _registry.call(name, **kwargs)
        return result
    except Exception as e:
        status = "error"
        error_obj = e
        raise
    finally:
        duration = (time.monotonic() - t0) * 1000
        _log_audit_entry(
            name,
            kwargs,
            status,
            _registry.level(None).name,
            duration,
            error_obj
        )

x_trusted_call_tool__mutmut_mutants : ClassVar[MutantDict] = {
'x_trusted_call_tool__mutmut_1': x_trusted_call_tool__mutmut_1, 
    'x_trusted_call_tool__mutmut_2': x_trusted_call_tool__mutmut_2, 
    'x_trusted_call_tool__mutmut_3': x_trusted_call_tool__mutmut_3, 
    'x_trusted_call_tool__mutmut_4': x_trusted_call_tool__mutmut_4, 
    'x_trusted_call_tool__mutmut_5': x_trusted_call_tool__mutmut_5, 
    'x_trusted_call_tool__mutmut_6': x_trusted_call_tool__mutmut_6, 
    'x_trusted_call_tool__mutmut_7': x_trusted_call_tool__mutmut_7, 
    'x_trusted_call_tool__mutmut_8': x_trusted_call_tool__mutmut_8, 
    'x_trusted_call_tool__mutmut_9': x_trusted_call_tool__mutmut_9, 
    'x_trusted_call_tool__mutmut_10': x_trusted_call_tool__mutmut_10, 
    'x_trusted_call_tool__mutmut_11': x_trusted_call_tool__mutmut_11, 
    'x_trusted_call_tool__mutmut_12': x_trusted_call_tool__mutmut_12, 
    'x_trusted_call_tool__mutmut_13': x_trusted_call_tool__mutmut_13, 
    'x_trusted_call_tool__mutmut_14': x_trusted_call_tool__mutmut_14, 
    'x_trusted_call_tool__mutmut_15': x_trusted_call_tool__mutmut_15, 
    'x_trusted_call_tool__mutmut_16': x_trusted_call_tool__mutmut_16, 
    'x_trusted_call_tool__mutmut_17': x_trusted_call_tool__mutmut_17, 
    'x_trusted_call_tool__mutmut_18': x_trusted_call_tool__mutmut_18, 
    'x_trusted_call_tool__mutmut_19': x_trusted_call_tool__mutmut_19, 
    'x_trusted_call_tool__mutmut_20': x_trusted_call_tool__mutmut_20, 
    'x_trusted_call_tool__mutmut_21': x_trusted_call_tool__mutmut_21, 
    'x_trusted_call_tool__mutmut_22': x_trusted_call_tool__mutmut_22, 
    'x_trusted_call_tool__mutmut_23': x_trusted_call_tool__mutmut_23, 
    'x_trusted_call_tool__mutmut_24': x_trusted_call_tool__mutmut_24, 
    'x_trusted_call_tool__mutmut_25': x_trusted_call_tool__mutmut_25, 
    'x_trusted_call_tool__mutmut_26': x_trusted_call_tool__mutmut_26, 
    'x_trusted_call_tool__mutmut_27': x_trusted_call_tool__mutmut_27, 
    'x_trusted_call_tool__mutmut_28': x_trusted_call_tool__mutmut_28, 
    'x_trusted_call_tool__mutmut_29': x_trusted_call_tool__mutmut_29, 
    'x_trusted_call_tool__mutmut_30': x_trusted_call_tool__mutmut_30, 
    'x_trusted_call_tool__mutmut_31': x_trusted_call_tool__mutmut_31, 
    'x_trusted_call_tool__mutmut_32': x_trusted_call_tool__mutmut_32, 
    'x_trusted_call_tool__mutmut_33': x_trusted_call_tool__mutmut_33, 
    'x_trusted_call_tool__mutmut_34': x_trusted_call_tool__mutmut_34, 
    'x_trusted_call_tool__mutmut_35': x_trusted_call_tool__mutmut_35, 
    'x_trusted_call_tool__mutmut_36': x_trusted_call_tool__mutmut_36, 
    'x_trusted_call_tool__mutmut_37': x_trusted_call_tool__mutmut_37, 
    'x_trusted_call_tool__mutmut_38': x_trusted_call_tool__mutmut_38, 
    'x_trusted_call_tool__mutmut_39': x_trusted_call_tool__mutmut_39, 
    'x_trusted_call_tool__mutmut_40': x_trusted_call_tool__mutmut_40, 
    'x_trusted_call_tool__mutmut_41': x_trusted_call_tool__mutmut_41, 
    'x_trusted_call_tool__mutmut_42': x_trusted_call_tool__mutmut_42, 
    'x_trusted_call_tool__mutmut_43': x_trusted_call_tool__mutmut_43, 
    'x_trusted_call_tool__mutmut_44': x_trusted_call_tool__mutmut_44, 
    'x_trusted_call_tool__mutmut_45': x_trusted_call_tool__mutmut_45, 
    'x_trusted_call_tool__mutmut_46': x_trusted_call_tool__mutmut_46, 
    'x_trusted_call_tool__mutmut_47': x_trusted_call_tool__mutmut_47, 
    'x_trusted_call_tool__mutmut_48': x_trusted_call_tool__mutmut_48, 
    'x_trusted_call_tool__mutmut_49': x_trusted_call_tool__mutmut_49, 
    'x_trusted_call_tool__mutmut_50': x_trusted_call_tool__mutmut_50, 
    'x_trusted_call_tool__mutmut_51': x_trusted_call_tool__mutmut_51, 
    'x_trusted_call_tool__mutmut_52': x_trusted_call_tool__mutmut_52, 
    'x_trusted_call_tool__mutmut_53': x_trusted_call_tool__mutmut_53, 
    'x_trusted_call_tool__mutmut_54': x_trusted_call_tool__mutmut_54, 
    'x_trusted_call_tool__mutmut_55': x_trusted_call_tool__mutmut_55, 
    'x_trusted_call_tool__mutmut_56': x_trusted_call_tool__mutmut_56, 
    'x_trusted_call_tool__mutmut_57': x_trusted_call_tool__mutmut_57, 
    'x_trusted_call_tool__mutmut_58': x_trusted_call_tool__mutmut_58, 
    'x_trusted_call_tool__mutmut_59': x_trusted_call_tool__mutmut_59, 
    'x_trusted_call_tool__mutmut_60': x_trusted_call_tool__mutmut_60, 
    'x_trusted_call_tool__mutmut_61': x_trusted_call_tool__mutmut_61, 
    'x_trusted_call_tool__mutmut_62': x_trusted_call_tool__mutmut_62, 
    'x_trusted_call_tool__mutmut_63': x_trusted_call_tool__mutmut_63, 
    'x_trusted_call_tool__mutmut_64': x_trusted_call_tool__mutmut_64, 
    'x_trusted_call_tool__mutmut_65': x_trusted_call_tool__mutmut_65, 
    'x_trusted_call_tool__mutmut_66': x_trusted_call_tool__mutmut_66, 
    'x_trusted_call_tool__mutmut_67': x_trusted_call_tool__mutmut_67, 
    'x_trusted_call_tool__mutmut_68': x_trusted_call_tool__mutmut_68, 
    'x_trusted_call_tool__mutmut_69': x_trusted_call_tool__mutmut_69, 
    'x_trusted_call_tool__mutmut_70': x_trusted_call_tool__mutmut_70, 
    'x_trusted_call_tool__mutmut_71': x_trusted_call_tool__mutmut_71, 
    'x_trusted_call_tool__mutmut_72': x_trusted_call_tool__mutmut_72, 
    'x_trusted_call_tool__mutmut_73': x_trusted_call_tool__mutmut_73, 
    'x_trusted_call_tool__mutmut_74': x_trusted_call_tool__mutmut_74, 
    'x_trusted_call_tool__mutmut_75': x_trusted_call_tool__mutmut_75, 
    'x_trusted_call_tool__mutmut_76': x_trusted_call_tool__mutmut_76, 
    'x_trusted_call_tool__mutmut_77': x_trusted_call_tool__mutmut_77, 
    'x_trusted_call_tool__mutmut_78': x_trusted_call_tool__mutmut_78, 
    'x_trusted_call_tool__mutmut_79': x_trusted_call_tool__mutmut_79, 
    'x_trusted_call_tool__mutmut_80': x_trusted_call_tool__mutmut_80, 
    'x_trusted_call_tool__mutmut_81': x_trusted_call_tool__mutmut_81, 
    'x_trusted_call_tool__mutmut_82': x_trusted_call_tool__mutmut_82, 
    'x_trusted_call_tool__mutmut_83': x_trusted_call_tool__mutmut_83, 
    'x_trusted_call_tool__mutmut_84': x_trusted_call_tool__mutmut_84, 
    'x_trusted_call_tool__mutmut_85': x_trusted_call_tool__mutmut_85, 
    'x_trusted_call_tool__mutmut_86': x_trusted_call_tool__mutmut_86, 
    'x_trusted_call_tool__mutmut_87': x_trusted_call_tool__mutmut_87, 
    'x_trusted_call_tool__mutmut_88': x_trusted_call_tool__mutmut_88, 
    'x_trusted_call_tool__mutmut_89': x_trusted_call_tool__mutmut_89, 
    'x_trusted_call_tool__mutmut_90': x_trusted_call_tool__mutmut_90, 
    'x_trusted_call_tool__mutmut_91': x_trusted_call_tool__mutmut_91, 
    'x_trusted_call_tool__mutmut_92': x_trusted_call_tool__mutmut_92, 
    'x_trusted_call_tool__mutmut_93': x_trusted_call_tool__mutmut_93, 
    'x_trusted_call_tool__mutmut_94': x_trusted_call_tool__mutmut_94, 
    'x_trusted_call_tool__mutmut_95': x_trusted_call_tool__mutmut_95, 
    'x_trusted_call_tool__mutmut_96': x_trusted_call_tool__mutmut_96, 
    'x_trusted_call_tool__mutmut_97': x_trusted_call_tool__mutmut_97, 
    'x_trusted_call_tool__mutmut_98': x_trusted_call_tool__mutmut_98, 
    'x_trusted_call_tool__mutmut_99': x_trusted_call_tool__mutmut_99, 
    'x_trusted_call_tool__mutmut_100': x_trusted_call_tool__mutmut_100, 
    'x_trusted_call_tool__mutmut_101': x_trusted_call_tool__mutmut_101, 
    'x_trusted_call_tool__mutmut_102': x_trusted_call_tool__mutmut_102, 
    'x_trusted_call_tool__mutmut_103': x_trusted_call_tool__mutmut_103, 
    'x_trusted_call_tool__mutmut_104': x_trusted_call_tool__mutmut_104, 
    'x_trusted_call_tool__mutmut_105': x_trusted_call_tool__mutmut_105, 
    'x_trusted_call_tool__mutmut_106': x_trusted_call_tool__mutmut_106, 
    'x_trusted_call_tool__mutmut_107': x_trusted_call_tool__mutmut_107, 
    'x_trusted_call_tool__mutmut_108': x_trusted_call_tool__mutmut_108, 
    'x_trusted_call_tool__mutmut_109': x_trusted_call_tool__mutmut_109, 
    'x_trusted_call_tool__mutmut_110': x_trusted_call_tool__mutmut_110, 
    'x_trusted_call_tool__mutmut_111': x_trusted_call_tool__mutmut_111, 
    'x_trusted_call_tool__mutmut_112': x_trusted_call_tool__mutmut_112, 
    'x_trusted_call_tool__mutmut_113': x_trusted_call_tool__mutmut_113, 
    'x_trusted_call_tool__mutmut_114': x_trusted_call_tool__mutmut_114, 
    'x_trusted_call_tool__mutmut_115': x_trusted_call_tool__mutmut_115, 
    'x_trusted_call_tool__mutmut_116': x_trusted_call_tool__mutmut_116, 
    'x_trusted_call_tool__mutmut_117': x_trusted_call_tool__mutmut_117, 
    'x_trusted_call_tool__mutmut_118': x_trusted_call_tool__mutmut_118, 
    'x_trusted_call_tool__mutmut_119': x_trusted_call_tool__mutmut_119, 
    'x_trusted_call_tool__mutmut_120': x_trusted_call_tool__mutmut_120, 
    'x_trusted_call_tool__mutmut_121': x_trusted_call_tool__mutmut_121, 
    'x_trusted_call_tool__mutmut_122': x_trusted_call_tool__mutmut_122, 
    'x_trusted_call_tool__mutmut_123': x_trusted_call_tool__mutmut_123, 
    'x_trusted_call_tool__mutmut_124': x_trusted_call_tool__mutmut_124, 
    'x_trusted_call_tool__mutmut_125': x_trusted_call_tool__mutmut_125, 
    'x_trusted_call_tool__mutmut_126': x_trusted_call_tool__mutmut_126, 
    'x_trusted_call_tool__mutmut_127': x_trusted_call_tool__mutmut_127, 
    'x_trusted_call_tool__mutmut_128': x_trusted_call_tool__mutmut_128, 
    'x_trusted_call_tool__mutmut_129': x_trusted_call_tool__mutmut_129, 
    'x_trusted_call_tool__mutmut_130': x_trusted_call_tool__mutmut_130, 
    'x_trusted_call_tool__mutmut_131': x_trusted_call_tool__mutmut_131, 
    'x_trusted_call_tool__mutmut_132': x_trusted_call_tool__mutmut_132, 
    'x_trusted_call_tool__mutmut_133': x_trusted_call_tool__mutmut_133, 
    'x_trusted_call_tool__mutmut_134': x_trusted_call_tool__mutmut_134, 
    'x_trusted_call_tool__mutmut_135': x_trusted_call_tool__mutmut_135, 
    'x_trusted_call_tool__mutmut_136': x_trusted_call_tool__mutmut_136, 
    'x_trusted_call_tool__mutmut_137': x_trusted_call_tool__mutmut_137, 
    'x_trusted_call_tool__mutmut_138': x_trusted_call_tool__mutmut_138, 
    'x_trusted_call_tool__mutmut_139': x_trusted_call_tool__mutmut_139, 
    'x_trusted_call_tool__mutmut_140': x_trusted_call_tool__mutmut_140, 
    'x_trusted_call_tool__mutmut_141': x_trusted_call_tool__mutmut_141, 
    'x_trusted_call_tool__mutmut_142': x_trusted_call_tool__mutmut_142, 
    'x_trusted_call_tool__mutmut_143': x_trusted_call_tool__mutmut_143, 
    'x_trusted_call_tool__mutmut_144': x_trusted_call_tool__mutmut_144, 
    'x_trusted_call_tool__mutmut_145': x_trusted_call_tool__mutmut_145, 
    'x_trusted_call_tool__mutmut_146': x_trusted_call_tool__mutmut_146, 
    'x_trusted_call_tool__mutmut_147': x_trusted_call_tool__mutmut_147, 
    'x_trusted_call_tool__mutmut_148': x_trusted_call_tool__mutmut_148, 
    'x_trusted_call_tool__mutmut_149': x_trusted_call_tool__mutmut_149, 
    'x_trusted_call_tool__mutmut_150': x_trusted_call_tool__mutmut_150, 
    'x_trusted_call_tool__mutmut_151': x_trusted_call_tool__mutmut_151, 
    'x_trusted_call_tool__mutmut_152': x_trusted_call_tool__mutmut_152, 
    'x_trusted_call_tool__mutmut_153': x_trusted_call_tool__mutmut_153, 
    'x_trusted_call_tool__mutmut_154': x_trusted_call_tool__mutmut_154, 
    'x_trusted_call_tool__mutmut_155': x_trusted_call_tool__mutmut_155, 
    'x_trusted_call_tool__mutmut_156': x_trusted_call_tool__mutmut_156, 
    'x_trusted_call_tool__mutmut_157': x_trusted_call_tool__mutmut_157, 
    'x_trusted_call_tool__mutmut_158': x_trusted_call_tool__mutmut_158, 
    'x_trusted_call_tool__mutmut_159': x_trusted_call_tool__mutmut_159, 
    'x_trusted_call_tool__mutmut_160': x_trusted_call_tool__mutmut_160, 
    'x_trusted_call_tool__mutmut_161': x_trusted_call_tool__mutmut_161, 
    'x_trusted_call_tool__mutmut_162': x_trusted_call_tool__mutmut_162, 
    'x_trusted_call_tool__mutmut_163': x_trusted_call_tool__mutmut_163, 
    'x_trusted_call_tool__mutmut_164': x_trusted_call_tool__mutmut_164, 
    'x_trusted_call_tool__mutmut_165': x_trusted_call_tool__mutmut_165, 
    'x_trusted_call_tool__mutmut_166': x_trusted_call_tool__mutmut_166, 
    'x_trusted_call_tool__mutmut_167': x_trusted_call_tool__mutmut_167, 
    'x_trusted_call_tool__mutmut_168': x_trusted_call_tool__mutmut_168, 
    'x_trusted_call_tool__mutmut_169': x_trusted_call_tool__mutmut_169, 
    'x_trusted_call_tool__mutmut_170': x_trusted_call_tool__mutmut_170, 
    'x_trusted_call_tool__mutmut_171': x_trusted_call_tool__mutmut_171, 
    'x_trusted_call_tool__mutmut_172': x_trusted_call_tool__mutmut_172, 
    'x_trusted_call_tool__mutmut_173': x_trusted_call_tool__mutmut_173, 
    'x_trusted_call_tool__mutmut_174': x_trusted_call_tool__mutmut_174, 
    'x_trusted_call_tool__mutmut_175': x_trusted_call_tool__mutmut_175, 
    'x_trusted_call_tool__mutmut_176': x_trusted_call_tool__mutmut_176, 
    'x_trusted_call_tool__mutmut_177': x_trusted_call_tool__mutmut_177, 
    'x_trusted_call_tool__mutmut_178': x_trusted_call_tool__mutmut_178, 
    'x_trusted_call_tool__mutmut_179': x_trusted_call_tool__mutmut_179, 
    'x_trusted_call_tool__mutmut_180': x_trusted_call_tool__mutmut_180, 
    'x_trusted_call_tool__mutmut_181': x_trusted_call_tool__mutmut_181, 
    'x_trusted_call_tool__mutmut_182': x_trusted_call_tool__mutmut_182, 
    'x_trusted_call_tool__mutmut_183': x_trusted_call_tool__mutmut_183, 
    'x_trusted_call_tool__mutmut_184': x_trusted_call_tool__mutmut_184, 
    'x_trusted_call_tool__mutmut_185': x_trusted_call_tool__mutmut_185, 
    'x_trusted_call_tool__mutmut_186': x_trusted_call_tool__mutmut_186, 
    'x_trusted_call_tool__mutmut_187': x_trusted_call_tool__mutmut_187, 
    'x_trusted_call_tool__mutmut_188': x_trusted_call_tool__mutmut_188, 
    'x_trusted_call_tool__mutmut_189': x_trusted_call_tool__mutmut_189
}

def trusted_call_tool(*args, **kwargs):
    result = _mutmut_trampoline(x_trusted_call_tool__mutmut_orig, x_trusted_call_tool__mutmut_mutants, args, kwargs)
    return result 

trusted_call_tool.__signature__ = _mutmut_signature(x_trusted_call_tool__mutmut_orig)
x_trusted_call_tool__mutmut_orig.__name__ = 'x_trusted_call_tool'


def get_current_trust_level() -> TrustLevel:
    """Return the current global trust level."""
    return _trust_level


def x_reset_trust__mutmut_orig() -> None:
    """Reset all trust levels to UNTRUSTED."""
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.UNTRUSTED
    _registry.reset()
    _trigger_trust_change(old_level, TrustLevel.UNTRUSTED)


def x_reset_trust__mutmut_1() -> None:
    """Reset all trust levels to UNTRUSTED."""
    global _trust_level
    old_level = None
    _trust_level = TrustLevel.UNTRUSTED
    _registry.reset()
    _trigger_trust_change(old_level, TrustLevel.UNTRUSTED)


def x_reset_trust__mutmut_2() -> None:
    """Reset all trust levels to UNTRUSTED."""
    global _trust_level
    old_level = _trust_level
    _trust_level = None
    _registry.reset()
    _trigger_trust_change(old_level, TrustLevel.UNTRUSTED)


def x_reset_trust__mutmut_3() -> None:
    """Reset all trust levels to UNTRUSTED."""
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.UNTRUSTED
    _registry.reset()
    _trigger_trust_change(None, TrustLevel.UNTRUSTED)


def x_reset_trust__mutmut_4() -> None:
    """Reset all trust levels to UNTRUSTED."""
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.UNTRUSTED
    _registry.reset()
    _trigger_trust_change(old_level, None)


def x_reset_trust__mutmut_5() -> None:
    """Reset all trust levels to UNTRUSTED."""
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.UNTRUSTED
    _registry.reset()
    _trigger_trust_change(TrustLevel.UNTRUSTED)


def x_reset_trust__mutmut_6() -> None:
    """Reset all trust levels to UNTRUSTED."""
    global _trust_level
    old_level = _trust_level
    _trust_level = TrustLevel.UNTRUSTED
    _registry.reset()
    _trigger_trust_change(old_level, )

x_reset_trust__mutmut_mutants : ClassVar[MutantDict] = {
'x_reset_trust__mutmut_1': x_reset_trust__mutmut_1, 
    'x_reset_trust__mutmut_2': x_reset_trust__mutmut_2, 
    'x_reset_trust__mutmut_3': x_reset_trust__mutmut_3, 
    'x_reset_trust__mutmut_4': x_reset_trust__mutmut_4, 
    'x_reset_trust__mutmut_5': x_reset_trust__mutmut_5, 
    'x_reset_trust__mutmut_6': x_reset_trust__mutmut_6
}

def reset_trust(*args, **kwargs):
    result = _mutmut_trampoline(x_reset_trust__mutmut_orig, x_reset_trust__mutmut_mutants, args, kwargs)
    return result 

reset_trust.__signature__ = _mutmut_signature(x_reset_trust__mutmut_orig)
x_reset_trust__mutmut_orig.__name__ = 'x_reset_trust'



# =====================================================================
# Constants (use the lazy definitions from lines ~198-199)
# =====================================================================


__all__ = [
    "TrustLevel",
    "TrustRegistry",
    "DESTRUCTIVE_TOOLS",
    "SAFE_TOOLS",
    "SAFE_TOOL_COUNT",
    "DESTRUCTIVE_TOOL_COUNT",
    "verify_capabilities",
    "trust_tool",
    "trust_all",
    "get_trust_report",
    "is_trusted",
    "trusted_call_tool",
    "trusted_call_tool",
    "get_audit_log",
    "export_audit_log",
    "clear_audit_log",
    "SecurityError",
    "get_current_trust_level",
]

